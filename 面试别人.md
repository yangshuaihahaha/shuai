# jdk新特性
速度更快 – 红黑树
代码更少 – Lambda
强大的Stream API – Stream
便于并行 – Parallel
最大化减少空指针异常 – Optional

# 五种数据类型
①String 是 Redis 最基本的类型
②Hash是一个键值（key-value）的集合
③List 列表是简单的字符串列表，按照插入顺序排序
④Set 是 String 类型的无序集合。
⑤Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。

# Redis 雪崩了解吗？
热点数据的缓存都是定时任务去刷新，如果首页所有 Key 的失效时间都是某一个时间节点，这个时间大量用户涌入，这些请求全部落在了数据库上这就是缓存雪崩
每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。

# Redis 穿透
缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据
而用户不断发起请求。攻击导致数据库压力很大，严重会击垮数据库。
缓存穿透我会在接口层增加校验
# Redis 击穿
某一个 Key 不停地扛着大量的请求，Key 在失效的瞬间，持续的大并发直接落到了数据库上
设置热点数据永不过期

# 怎样设计api
代码松耦合，用更加通俗的语言来描述就是：“不应该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口”。（“软件实体”替换成“类”）
建议优先使用接口而不是具体实现类
参数有效性检查
返回长度为零的数组或集合，而非null
规范文档注释
避免过长的参数列表
避免相同参数数量的重载方法

# spring的启动

# spring boot面试
Spring Boot的全局异常处理？
Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。通过实现一个ControlerAdvice类，来处理控制类抛出的所有异常。

# 为什么线程执行完不会立即释放

# 极端情况下高并发解决方案

# ArrayList方法add和remove的时间复杂度

# spring boot的自动装配

# spring boot的启动流程

# 如何自定义一个spring starter

# Hive调优

# Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。
## Zookeeper保证CP
当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
## Eureka保证AP
Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)
3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中
因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。
# 微服务技术栈
- 维度(springcloud)
- 服务开发：springboot spring springmvc
- 服务配置与管理:Netfix公司的Archaiusm ,阿里的Diamond
- 服务注册与发现:Eureka,Zookeeper
- 服务调用:Rest RPC gRpc
- 服务熔断器:Hystrix
- 服务负载均衡:Ribbon Nginx
- 服务接口调用:Fegin
- 消息队列:Kafka Rabbitmq activemq
- 服务配置中心管理:SpringCloudConfig
- 服务路由（API网关）Zuul
- 事件消息总线:SpringCloud Bus

# dubbo的spi机制

# roubit mq 的交换有几种

# 对于几种消息队列的选型

# 怎么保证两个服务之间的一致性

# 一个服务端崩溃了，有什么预警机制

# 雪花算法

# 时钟不同步

# ZAB协议用途

# redis为什么单线程还高效

# Reactor的三种线程模型

# MinorGC 和 FullGC的理解





