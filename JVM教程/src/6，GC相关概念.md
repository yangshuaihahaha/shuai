# System.gc()
默认情况下System.gc()会显式触发Full GC，同时对老年代和新生代进行回收
但是无法保证对垃圾收集器的调用，不一定会执行
与Runtime。getRuntime().gc()；的作用是一样的
System.runFinalization()//强制调用失去引用的对象的finalize()方法
          
# 内存溢出
没有空闲内存，并且垃圾回收器无法提供更多内存
原因：
    1，Java虚拟机内存设置不够
        比如存在内存泄漏问题；堆的大小不合理
    2，代码中创建大量大对象，长时间不能被垃圾收集器收集（存在被引用）

# 内存泄漏
对象不会再被程序用到，但是GC又不能回收他们的情况，才叫内存泄漏
举例：
    1，单例模式：
        单里的生命周期和引用程序一样，所以单例程序中，如果持有对外部对象引用，那么这个外部对象是不能被回收的，则会导致内存泄漏发生
    2，一些提供close的资源未关闭导致内存泄漏
        数据库连接，网络连接和io连接必须手动close，否则不能被回收
    
# Stop The Word
指的是在GC事件发生过程中，会产生应用程序的停顿，停顿产生时整个应用程序会暂停，没有任何响应

可达性分析算法中枚举根节点会导致Java执行线程停顿
    - 分析工作必须在一个能确保一致性的快照中进行
    - 一致性指的是分析期间整个系统看起来像是冻结在某个时间节点上
    - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

STW事件和采用哪一款GC无关，所有的GC都有这个事件

哪怕是G1也不能完全避免STW，只能说垃圾回收越优秀，回收效率越高，尽可能缩短了暂停时间

STW是JVM在后台自动发起和自动完成的。用户不可见的情况下，把用户正常的工作线程全部停掉

# 并行和并发
并发指的是多个事情，在同一时间段内同时发生了，多个任务之间相互抢占资源
并行指的是多个事情在同一时间节点发生，多个任务之间是不相互抢占资源的

# 安全点和安全区域
安全点：
    程序运行期间，并非所有的地方都能停顿下来开始GC，只有特定的位置才能停下来GC，这些位置称为安全点
    安全点的选择很重要，如果太少可能导致等待时间过长，太多导致性能不好。
    如何在GC时，检查所有线程跑到最近的安全点停顿下来：
        - 抢先中断（目前没有虚拟机使用了）
            首先中断线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点
        - 主动中断
            设置一个中断标志，各个线程运行到Safe Point的时候主动轮训这个标志，如果中断标志为真，将自己进行中断挂起
            
安全区域：
    安全区域是指一段代码片段中，对象的引用关系不会发生变化，这个区域中任何位置开始GC都是安全的
    
    
# 引用
引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）
四种强度一次递减

- 强引用（永远不回收）
    -> 传统引用的定义，是指程序代码之中普遍存在的引用赋值，类似"Object obj = new Object()"这种引用关系。
    -> 无论任何情况下，只要强引用关系存在，垃圾回收器永远不会回收被引用的对象
    -> 强引用对象是可触及的，垃圾回收器永远不会回收掉被引用的对象。
    -> 相对的，软引用、弱引用和虚引用对象是软可触及、弱可触及和虚可触及的，在一定条件下是可以被回收的。所以强引用是Java内存泄漏的主要原因之一
- 软引用（内存不足即回收）
    -> 描述一些有用但是非必须的对象
    -> 系统将发生内存溢出之前，将会把这些对象列入回收范围之内进行二次回收。如果回收之后没有足够的内存才会抛出内存溢出异常
    -> 软引用通常用来实现内存敏感的缓存。比如：高速缓存就用到了软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉
    -> 类似弱引用，只不过Java虚拟机会尽量让软引用存活的时间长一些，迫不得已才清理
```java
import java.lang.ref.SoftReference;
 
public class Tests {
	public static void main(String[] args) {
		String src = new String("我是强引用");
		SoftReference<String> softRef=new SoftReference<String>(src); 
		System.out.println(src);
		System.out.println(softRef);
	}
}
```
- 弱引用（发现即回收）
    -> 当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象
    -> 但是由于垃圾回收器的线程优先级很低，因此，并不一定很快发现持有弱引用的对象。在这种情况下弱引用对象可以存在较长时间
    -> 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。当内存不足时，缓存数据会被回收，不会导致内存溢出，内存资源充足时，缓存数据加速系统
```java
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
 
public class Tests {
	public static void main(String[] args) {
		String src = new String("我是强引用");
		SoftReference<String> softRef=new SoftReference<String>(src); //软引用
		WeakReference<String> wr = new WeakReference<String>(src);//弱引用
//		System.out.println(src);
//		System.out.println(softRef);
		System.out.println(wr);
		System.gc();
	}
}
```
- 虚引用
    -> 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象实例。
    -> 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
    -> 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，
       就会在回收对象后，将这个虚引用加入到引用队列，以通知应用程序对象的回收情况
    -> 由于虚引用可以跟踪对象回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录     
    




    