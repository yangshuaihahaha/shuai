# 认识 HTTP
HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)。那么什么是超文本传输协议？
超文本传输协议可以进行文字分割：超文本（Hypertext）、传输（Transfer）、协议（Protocol），它们之间的关系如下
按照范围的大小 协议 > 传输 > 超文本
什么是超文本：
    在互联网早期的时候，我们输入的信息只能保存在本地，无法和其他电脑进行交互。我们保存的信息通常都以文本即简单字符的形式存在，
    文本是一种能够被计算机解析的有意义的二进制数据包。而随着互联网的高速发展，两台电脑之间能够进行数据的传输后，人们不满足只能在两台电脑之间传输文字，
    还想要传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转，那么文本的语义就被扩大了，这种语义扩大后的文本就被称为超文本(Hypertext)
什么是传输：
    两台计算机之间会形成互联关系进行通信，我们存储的超文本会被解析成为二进制数据包，由传输载体（例如同轴电缆，电话线，光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程
    通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。
什么是协议：
    网络协议就是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议。
经典的总结：
    HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范
# 网络模型
因特网的协议栈由五个部分组成：物理层、链路层、网络层、运输层和应用层
应用层
    （主要协议有HTTP、Telnet、FTP、SMTP等，是用来读取来自传输层的数据或者将数据传输写入传输层；）
    应用层包括所有和应用程序协同工作，并利用基础网络交换应用程序的业务数据的协议。
    一些特定的程序被认为运行在这个层上，该层协议所提供的服务能直接支持用户应用
    应用层协议包括HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（域名解析）以及许多其他协议。
传输层
    （传输层的主要协议有UDP、TCP，实现端对端的数据传输；）
    传输层的协议，解决了诸如端到端可靠性问题，能确保数据可靠的到达目的地，甚至能保证数据按照正确的顺序到达目的地。传输层的主要功能大致如下：
        （1）为端到端连接提供传输服务；
        （2）这种传输服务分为可靠和不可靠的，其中TCP是典型的可靠传输，而UDP则是不可靠传输；
        （3）为端到端连接提供流量控制、差错控制、QoS(Quality of Service)服务质量等管理服务。
    传输层主要有两个性质不同的协议：TCP传输控制协议和UDP用户数据报协议。
    1，TCP协议是一个面向连接的、可靠的传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。
    2，UDP协议是一个无连接的数据报协议，是一个“尽力传递”和“不可靠”协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达。
    总体来说，TCP协议传输效率低，但可靠性强；UDP协议传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据）。
网络层
    （网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等）
    网络层的作用是在复杂的网络环境中为要发送的数据报找到一个合适的路径进行传输。简单来说，网络层负责将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址。
链路层
    链路层有时也称作数据链路层或网络接口层，用来处理连接网络的硬件部分。
    该层既包括操作系统硬件的设备驱动、NIC（网卡）、光纤等物理可见部分，还包括连接器等一切传输媒介。
    在这一层，数据的传输单位为比特。其主要协议有ARP、RARP等。
# CDN
CDN的全称是Content Delivery Network，即内容分发网络，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。
CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
CDN的关键技术主要有内容存储和分发技术。
具体流程：
    假设通过CDN加速的域名为www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：
    1，当终端用户（北京）向www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。
    2，LDNS检查缓存中是否有www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。
    3，当授权DNS解析www.a.com时，返回域名CNAME www.a.tbcdn.com对应IP地址。
    4，域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。
    5，LDNS获取DNS返回的解析IP地址。
    6，用户获取解析IP地址。
    7，用户向获取的IP地址发起对该资源的访问请求。
        1）如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，请求结束。
        2）如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。
# WAF
WAF 是一种 Web 应用程序防护系统（Web Application Firewall，简称 WAF），它是一种通过执行一系列针对HTTP / HTTPS的安全策略来专门为Web应用提供保护的一款产品，
它是应用层面的防火墙，专门检测 HTTP 流量，是防护 Web 应用的安全技术。
WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。
# WebService
WebService 是一种 Web 应用程序，WebService是一种跨编程语言和跨操作系统平台的远程调用技术。
Web Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。
XML,SOAP和WSDL就是构成WebService平台的三大技术 。
    WebService采用Http协议来在客户端和服务端之间传输数据。WebService使用XML来封装数据，XML主要的优点在于它是跨平台的。
    WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议规定的。
    WebService服务器端首先要通过一个WSDL文件来说明自己有什么服务可以对外调用。简单的说，WSDL就像是一个说明书，用于描述WebService及其方法、参数和返回值。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：
        1.注册到UDDI服务器，以便被人查找；
        2.直接告诉给客户端调用者。
# DNS
你有没有想过为什么你可以通过键入 www.google.com 就能够获取你想要的网站？我们上面说到，计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 DNS 协议。
DNS 的全称是域名系统（Domain Name System，缩写：DNS），它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。
# HTTPS
HTTP 一般是明文传输，很容易被攻击者窃取重要信息，鉴于此，HTTPS 应运而生。
HTTPS 的全称为 （Hyper Text Transfer Protocol over SecureSocket Layer），全称有点长，HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。
HTTPS 在 HTTP 的基础上增加了 SSL 层，也就是说 HTTPS = HTTP + SSL。（这块我们后面也会详谈 HTTPS）
# HTTP 请求响应过程
1，DNS服务器会首先进行域名的映射，找到访问www.someSchool.edu所在的地址，然后HTTP 客户端进程在 80 端口发起一个到服务器 www.someSchool.edu 的 TCP 连接（80 端口是 HTTP 的默认端口）。在客户和服务器进程中都会有一个套接字与其相连。
2，HTTP 客户端通过它的套接字向服务器发送一个 HTTP 请求报文。该报文中包含了路径 someDepartment/home.index 的资源，我们后面会详细讨论 HTTP 请求报文。
3，HTTP 服务器通过它的套接字接受该报文，进行请求的解析工作，并从其存储器(RAM 或磁盘)中检索出对象 www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到 HTTP 响应报文中，并通过套接字向客户进行发送。
4，HTTP 服务器随即通知 TCP 断开 TCP 连接，实际上是需要等到客户接受完响应报文后才会断开 TCP 连接。
5，HTTP 客户端接受完响应报文后，TCP 连接会关闭。HTTP 客户端从响应中提取出报文中是一个 HTML 响应文件，并检查该 HTML 文件，然后循环检查报文中其他内部对象。
6，检查完成后，HTTP 客户端会把对应的资源通过显示器呈现给用户。
# HTTP 请求特征
1，支持客户-服务器模式
2，简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
3，灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
4，无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5，无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
# 详解 HTTP 报文
我们上面描述了一下 HTTP 的请求响应过程，流程比较简单，但是凡事就怕认真，你这一认真，就能拓展出很多东西，比如 HTTP 报文是什么样的，它的组成格式是什么？ 下面就来探讨一下
HTTP 协议主要由三大部分组成：
    起始行（start line）：描述请求或响应的基本信息；
        GET /baidu/page.html HTTP/1.1
        由三个字段组成：方法、URL 字段和 HTTP 版本字段。
    头部字段（header）：使用 key-value 形式更详细地说明报文；
        access-control-allow-credentials: true
        access-control-allow-origin: https://www.cnblogs.com
        content-length: 0
        date: Wed, 25 Aug 2021 02:57:26 GMT
        vary: Origin
    消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。
其中起始行和头部字段并成为 请求头 或者 响应头，统称为 Header；消息正文也叫做实体，称为 body。HTTP 协议规定每次发送的报文必须要有 Header，但是可以没有 body，也就是说头信息是必须的，实体信息可以没有。而且在 header 和 body 之间必须要有一个空行（CRLF）
# HTTP 请求方法
1，GET 获取资源
    GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；
2，POST 传输实体
    虽然 GET 方法也可以传输主体信息，但是便于区分，我们一般不用 GET 传输实体信息，反而使用 POST 传输实体信息
3，PUT 传输文件
    PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置
    但是，鉴于 HTTP 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 W eb 网站不使用该方法。
    若配合 W eb 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。
4，HEAD 获得响应首部
    HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。
5，DELETE 删除文件
    DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。
6，OPTIONS 询问支持的方法
    OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。
7，TRACE 追踪路径
    TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。
8，CONNECT 要求用隧道协议连接代理
    CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。
# HTTP 请求 URL
1，协议：http
    http://告诉浏览器使用何种协议。对于大部分 Web 资源，通常使用 HTTP 协议或其安全版本，HTTPS 协议。
    另外，浏览器也知道如何处理其他协议。例如， mailto: 协议指示浏览器打开邮件客户端；ftp:协议指示浏览器处理文件传输。
2，主机：www.example.com
    www.example.com 既是一个域名，也代表管理该域名的机构。它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 IP address 地址发起请求。但直接使用 IP 地址的场景并不常见。
3，端口：80
    我们前面说到，两个主机之间要发起 TCP 连接需要两个条件，主机 + 端口。它表示用于访问 Web 服务器上资源的入口。如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。
    上面是请求 URL 所必须包含的部分，下面就是 URL 具体请求资源路径
4，路径：/path/to/myfile.html
    /path/to/myfile.html 是 Web 服务器上资源的路径。以端口后面的第一个 / 开始，到 ? 号之前结束，中间的 每一个/ 都代表了层级（上下级）关系。这个 URL 的请求资源是一个 html 页面。
5，查询参数：?key1=value1&key2=value2
    ?key1=value1&key2=value2 是提供给 Web 服务器的额外参数。如果是 GET 请求，一般带有请求 URL 参数，如果是 POST 请求，则不会在路径后面直接加参数。这些参数是用 & 符号分隔的键/值对列表。key1 = value1 是第一对，key2 = value2 是第二对参数
6，锚点：#SomewhereInTheDocument
    #SomewhereInTheDocument 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。
    例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。
# 请求头部
HTTP 的请求标头分为四种： 通用标头、请求标头、响应标头 和 实体标头，依次来进行详解。
通用标头
    通用标头主要有三个，分别是 Date、Cache-Control 和 Connection
    Date
        Date 是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下
        Date: Wed, 21 Oct 2015 07:28:00 GMT 
    Cache-Control
        Cache-Control 是一个通用标头，他可以出现在请求标头和响应标头中
        Cache-Control 的种类比较多，虽然说这是一个通用标头，但是又一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 可缓存性、阈值性、 重新验证并重新加载 和其他特性
    Connection
        Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是持久性连接，即一次事务完成后不关闭网络连接
            Connection: keep-alive
        另一种是非持久性连接，即一次事务完成后关闭网络连接
            Connection: close
实体标头
    实体标头是描述消息正文内容的 HTTP 标头。实体标头用于 HTTP 请求和响应中。头部Content-Length、 Content-Language、 Content-Encoding 是实体头。
    - Content-Length 实体报头指示实体主体的大小，以字节为单位，发送到接收方。
    - Content-Language 实体报头描述了客户端或者服务端能够接受的语言，例如
        Content-Language: de-DE
        Content-Language: en-US
        Content-Language: de-DE, en-CA
    - Content-Encoding 这又是一个比较麻烦的属性，这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。
        常见的内容编码有这几种： gzip、compress、deflate、identity ，这个属性可以应用在请求报文和响应报文中
        Accept-Encoding: gzip, deflate //请求头
        Content-Encoding: gzip  //响应头
请求标头
    上面给出的例子请求报文的属性比较少，下面给出一个 MDN 官网的例子
        GET /home.html HTTP/1.1
        Host: developer.mozilla.org
        User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
        Accept-Language: en-US,en;q=0.5
        Accept-Encoding: gzip, deflate, br
        Referer: https://developer.mozilla.org/testpage.html
        Connection: keep-alive
        Upgrade-Insecure-Requests: 1
        If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
        If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"
        Cache-Control: max-age=0 
    Host
        Host 请求头指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号。如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个 HTTP 的 URL 会自动使用80作为端口）。
            Host: developer.mozilla.org
        上面的 Accpet、 Accept-Language、Accept-Encoding 都是属于内容协商的请求标头，我们会在下面说明
    Referer
        HTTP Referer 属性是请求标头的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。
        Referer: https://developer.mozilla.org/testpage.html
    Upgrade-Insecure-Requests
        Upgrade-Insecure-Requests 是一个请求标头，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应。
        Upgrade-Insecure-Requests: 1
    If-Modified-Since
        HTTP 的 If-Modified-Since 使其成为条件请求：
            返回200，只有在给定日期的最后一次修改资源后，服务器才会以200状态发送回请求的资源。
            如果请求从开始以来没有被修改过，响应会返回304并且没有任何响应体
        If-Modified-Since 通常会与 If-None-Match 搭配使用，If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。
        大白话说就是如果在 Last-Modified 之后更新了服务器资源，那么服务器会响应200，如果在 Last-Modified 之后没有更新过资源，则返回 304。
            If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
    If-None-Match
        If-None-Match HTTP请求标头使请求成为条件请求。 对于 GET 和 HEAD 方法，仅当服务器没有与给定资源匹配的 ETag 时，服务器才会以200状态发送回请求的资源。 对于其他方法，仅当最终现有资源的ETag与列出的任何值都不匹配时，才会处理请求。
            If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"
        ETag 属于响应标头，后面进行介绍。
    内容协商
        内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的标准。
        内容协商主要有以下3种类型：
            服务器驱动协商（Server-driven Negotiation）
                这种协商方式是由服务器端进行内容协商。服务器端会根据请求首部字段进行自动处理
            客户端驱动协商（Agent-driven Negotiation）
                这种协商方式是由客户端来进行内容协商。
            透明协商（Transparent Negotiation）
                是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。
            内容协商的分类有很多种，主要的几种类型是 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。
                Accept
                    接受请求 HTTP 标头会通告客户端其能够理解的 MIME 类型，也就是说，MIME 类型其实就是一系列消息内容类型的集合。那么 MIME 类型都有哪些呢？
                        文本文件： text/html、text/plain、text/css、application/xhtml+xml、application/xml
                        图片文件： image/jpeg、image/gif、image/png
                        视频文件： video/mpeg、video/quicktime
                        应用程序二进制文件： application/octet-stream、application/zip
                    比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。
                Accept-Charset
                      accept-charset 属性规定服务器处理表单数据所接受的字符集。
                      accept-charset 属性允许您指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。
                      该属性的值是用引号包含字符集名称列表。如果可接受字符集与用户所使用的字符即不相匹配的话，浏览器可以选择忽略表单或是将该表单区别对待。
                      此属性的默认值是 unknown，表示表单的字符集与包含表单的文档的字符集相同。
                      常用的字符集有： UTF-8 - Unicode 字符编码 ； ISO-8859-1 - 拉丁字母表的字符编码
                Accept-Language
                    首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。 和 Accept 首部字段一样，按权重值 q来表示相对优先级。
                        Accept-Language: en-US,en;q=0.5
# 响应标头
200 OK
Access-Control-Allow-Origin: *
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Mon, 18 Jul 2016 16:06:00 GMT
Etag: "c561c68d0ba92bbeb8b0f612a9199f722e3a621a"
Keep-Alive: timeout=5, max=997
Last-Modified: Mon, 18 Jul 2016 02:36:04 GMT
Server: Apache
Set-Cookie: mykey=myvalue; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding
x-frame-options: DENY
响应状态码
    以 2xx 为开头的都表示请求成功响应。
        200	成功响应
        204	请求处理成功，但是没有资源可以返回
        206	对资源某一部分进行响应，由Content-Range 指定范围的实体内容。
    以 3xx 为开头的都表示需要进行附加操作以完成请求
        301 永久性重定向，该状态码表示请求的资源已经重新分配  URI，以后应该使用资源现有的 URI
        302 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。
        303 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。
        304 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。
        307 临时重定向。该状态码与 302 Found 有着相同的含义。
    以 4xx 的响应结果表明客户端是发生错误的原因所在。
        400 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。
        401 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。
        403 该状态码表明对请求资源的访问被服务器拒绝了。
        404 该状态码表明服务器上无法找到请求的资源。
    以 5xx 为开头的响应标头都表示服务器本身发生错误
        500	该状态码表明服务器端在执行请求时发生了错误。
        503	该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
Access-Control-Allow-Origin
    一个返回的 HTTP 标头可能会具有 Access-Control-Allow-Origin ，Access-Control-Allow-Origin 指定一个来源，它告诉浏览器允许该来源进行资源访问。 否则-对于没有凭据的请求 *通配符，告诉浏览器允许任何源访问资源。例如，要允许源 https://mozilla.org 的代码访问资源，可以指定：
        Access-Control-Allow-Origin: https://mozilla.org
        Vary: Origin
Keep-Alive
    Keep-Alive 表示的是 Connection 非持续连接的存活时间，如下
        Connection: Keep-Alive
        Keep-Alive: timeout=5, max=997
    timeout：指示空闲连接必须保持打开状态的最短时间（以秒为单位）。
    max：指示在关闭连接之前可以在此连接上发送的最大请求数。
Server
    服务器标头包含有关原始服务器用来处理请求的软件的信息。
    应该避免使用过于冗长和详细的 Server 值，因为它们可能会泄露内部实施细节，这可能会使攻击者容易地发现并利用已知的安全漏洞。例如下面这种写法
        Server: Apache/2.4.1 (Unix)
Set-Cookie
    Cookie 又是另外一个领域的内容了，我们后面文章会说道 Cookie，这里需要记住 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们不是属于 HTTP 1.1 的首部字段，但是使用率仍然很高。
Transfer-Encoding
    首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。
        Transfer-Encoding: chunked
    HTTP /1.1 的传输编码方式仅对分块传输编码有效。
X-Frame-Options
    HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。
    首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。
# HTTP 的优点和缺点
HTTP 的优点
    1，HTTP 最重要也是最突出的优点是 简单、灵活、易于扩展。
    2，HTTP 的协议比较简单，它的主要组成就是 header + body，头部信息也是简单的文本格式，而且 HTTP 的请求报文根据英文也能猜出来个大概的意思，降低学习门槛，能够让更多的人研究和开发 HTTP 应用
    3，HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被制定死，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由。
    4，因为过于简单，普及，因此应用很广泛。因为 HTTP 协议本身不属于一种语言，它并不限定某种编程语言或者操作系统，所以天然具有跨语言、跨平台的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具。
    5，随着移动互联网的发展， HTTP 的触角已经延伸到了世界的每一个角落，从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP、新闻、论坛、购物、手机游戏，你很难找到一个没有使用 HTTP 的地方。
    6，无状态其实既是优点又是缺点。因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
HTTP 的缺点
    1，既然服务器没有记忆能力，它就无法支持需要连续多个步骤的事务操作。每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。由此出现了 Cookie 技术。
    2，HTTP 协议里还有一把优缺点一体的双刃剑，就是明文传输。明文意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。
    3，对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利。
    4，当然缺点也是显而易见的，就是不安全，可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被更改过。
    5，HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。
# 什么是socket
socket是对tcp/ip协议的封装，它的出现只是使得程序员更方便的使用tcp/ip协议栈而已。
socket本身并不是协议，它是应用层与tcp/ip协议族通信的中间软件抽象层，是一组调用接口（tcp/ip网络的api函数）
关于socket和tcp/ip协议关系比较容易理解的说法：
    tcp/ip只是一个协议栈，就像操作系统运行机制一样，必须要有具体的实现，同时还要有对外的操作接口
    这就像操作系统会提供标准的编程接口，比如win32编程接口一样
    tcp/ip也要提供可供程序员做网络开发所用的接口，这就是socket编程接口
    http是轿车，提供了封装或者显示数据的具体形式；socket是发动机，提供了网络通信的能力
实际上，传输层的tcp是基于网络层的ip协议的，而应用层的http协议又是基于传输层的http协议的，而socket本身不算是协议，
就像上面说的，他只是提供了一个针对tcp或者udp编程的接口
# http连接和socket连接的区别
区分两个概念还是比较有意义的，毕竟tcp看不见摸不着，htpp与socket是实实在在能用到的
- http是短链接，socket是（基于tcp协议）长连接。尽管http1.1开始支持持久连接，但是仍然无法保证始终连接。而socket连接一旦建立tcp三次握手，除非一方主动断开，否则连接状态一直保持
- http连接服务端无法主动发消息，socket连接双方请求的发送先后限制。这点就比较重要了，因为它将决定二者分别适合应用在什么场景下。
  http采用"请求-响应"机制，在客户端还没有发送消息给服务端前，服务端无法推送消息给客户端。必须满足客户端发送消息在前，服务端回复在后。
  socket连接双方类似peer2peer的关系，一方随时可以向另一方喊话
# 什么时候用http，什么时候用socket
这个问题的提出是很自然而然的。当你接到一个与另一方的网络通讯需求，自然会考虑用HTTP还是用Socket。
- 用HTTP的情况：双方不需要时刻保持连接在线，比如客户端资源的获取、文件上传等。
- 用Socket的情况：大部分即时通讯应用(QQ、微信)、聊天室等等。
# TCP和UDP
UDP
    UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接协议。
    UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。
    特点
        1，面向无连接
            首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。
            具体来说就是：
                在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
                在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
        2，有单播，多播，广播的功能
            UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。
        3，UDP是面向报文的
            发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。
            UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文
        4，不可靠性
            首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
            并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
            再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
        5，头部开销小，传输数据报文时是很高效的。
            UDP 头部包含了以下几个数据：
                两个十六位的端口号，分别为源端口（可选字段）和目标端口
                整个数据报文的长度
                整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误
            因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的
TCP
    当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。
    例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。
    当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。
    TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。
    
        


           
            
  












https://juejin.cn/post/6844904045572800525
https://www.cnblogs.com/crazymakercircle/p/14499211.html
https://juejin.cn/post/6844903970477981704