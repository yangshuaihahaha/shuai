# 对象存活判断
- GC执行垃圾回收之前，首先需要区分出内存中那些对象是存活的，那些是死亡的。只有被标记为已经死亡的对象才会被垃圾回收。这个阶段称为垃圾标记阶段
- 一个对象已经不再被任何对象引用时，就可以宣判为死亡对象
- 判断对象存活一般有两种方式：引用计数算法和可达性分析算法

# 引用计数算法（java中没有使用）
- 对每个对象保存一个整形的引用计数属性。用于记录对象被引用情况。
- 只要一个对象被引用，计数器就加1；引用失效时，引用计数器就减1。只要对象A的引用计数值为0，就表示该对象不需要被使用，可以回收
- 优点：
    实现简单；
    垃圾对象便有辨识；
    判定效率高；
    回收没有延迟
- 缺点：
    需要单独的字段存储计数器，增加了存储空间开销；
    每次赋值需要重新计数，增加时间开销；
    一个严重问题，无法处理循环引用情况，导致Java垃圾回收器中没有这类算法
    
# 可达性分析算法（搜索算法，追踪性垃圾收集）
可达性分析算法不仅同样具备实现简单和执行高效。而且可以有效的解决循环引用的问题。
基本思路：
    - 以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象所连接的目标对象是否可达
    - 使用可达性分析算法后，内存中存活的对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链
    - 如果目标对象没有任何引用链，则是不可达的，意味着对象已经死亡，可以标记为垃圾对象
    - 可达性分析算法中，只有能够被根对象直接或者间接连接的对象才是存活对象

# GC Roots包含一下几类元素
- 虚拟机栈中的引用对象
    比如各个线程被调用的方法中使用到的参数、局部变量
- 本地方法栈引用的对象
- 方法区中类静态属性引用的对象
    比如Java类的引用类型静态变量
- 方法区中常量引用的对象
    比如字符串常量池中的引用
- 所有被同步锁synchronized持有的对象
- Java虚拟机内部引用
小技巧：由于Root采用栈方式存放变量和指针，所以发现一个指针，它保存了堆内存中的对象，但是自己又不在堆内存里面，那它就是一个Root 


# 对象的finalization机制
- Java提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑
- 在进行垃圾回收之前总会先调用对象的finalize()方法
- finalize()方法允许在子类被重写，用于对象被回收时进行资源释放。
    通常这个方法进行一些资源释放和清理工作，比如关闭文件、套接字和数据库连接
    
- 永远不要主动调用对象的finalize()方法，应该交给垃圾回收机制调用。理由是：
    1，在finalize()时可能会导致对象复活
    2，finalize()方法的执行时间是没有保障的
    3，一些糟糕的finalize()会严重影响GC性能
    
- 由于finalize的存在，虚拟机中的对象一般可能存在三种状态：
    1，可触及的：从根节点开始，可以到达对象
    2，可复活的：对象的所有引用被释放，但是对象在finalize()中复活
    3，不可触及的：对象的finalize()被调用，并且没有被复活。
    
# 垃圾清除阶段
当区分出内存中存活和死亡对象后，GC接下来的任务就是执行垃圾回收。释放掉无用内存

JVM中常见的三种垃圾收集算法是：
    清除算法、复制算法、标记-压缩算法
    
## 1，标记清除算法
当堆中有效内存空间耗尽时，就会停止整个程序，然后进行两项工作，第一项则是标记，第二项是清除
    - 标记：Collector从引用根节点开始遍历，标记所有被引用对象。一般是在对象头中记录可达对象
    - 清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在Header中没有标记可达对象，则将其回收
缺点：
    效率不高
    在进行GC的时候，需要停止整个程序
    清理出来的空闲内存不是连续的，产生内存碎片。需要维护一个空闲列表

注意：何为清除？N 
    这里所谓的清除并不是真的置空，而是需要把清除对象地址保存在空闲的地址列表。下次有新对象需要加载时，
    判断垃圾的位置空间是否够，如果够就存放
    
## 2，复制算法
将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中存活的对象复制到未被使用的内存块中
之后清除正在使用的内存块中所有对象，交换两个内存的角色，最后完成垃圾回收。它的高效性建立在存活对象少、垃圾对象多的前提下

优点：
    - 没有标记清除过程，实现简单，运行高效
    - 复制过去以后保证空间的连续性，不会出现碎片问题
缺点：
    - 需要两倍的内存空间
    - 对于G1这种分拆成为大量的region的GC，复制而不是移动，意味着GC需要维护region之间的对象引用关系，不管是内存占用活着时间开销也不小
特别的：
    如果系统中垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。如果存活的对象很多那么复制到另一个区是没有意义的（什么垃圾都没有回收掉，还把栈空间所有的引用地址都重置了，效率极低）
应用场景：
    在新生代，对常规应用进行垃圾回收，一次通常可以回收70%-80%的内存空间。回收的性价比很高，所以现在的商业虚拟机都是使用这种收集算法回收新生代


## 3，标记整理算法
执行过程：
    第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象
    第二阶段将所有的存活对象压缩到内存的一端，按顺序存放。
    之后，清理边界外所有空间
    
标记-压缩算法最终的效果相当于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩算法

二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策

可以看到，标记的存活对象会被整理，按照内存地址依次排序，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，jvm只需要持有一个内存起始地址即可，这比维护一个空闲列表显然少了很多开销

优点：
    - 消除了标记-清除算法中，内存区域分散的缺点，我们需要给对象分配内存时，jvm只需要持有一个内存的起始地址即可
    - 消除了复制算法中，内存减半的高额代价
缺点：
    - 从效率上，标记-整理算法低于复制算法
    - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用地址
    - 移动过程中，需要全程暂停用户应用程序
    
# 分代收集算法
- 年轻代
    年轻代特点：区域相对老年代较小，对象生命周期短、存活率低、回收频繁
    这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代回收。
    而复制算法内存利用率不高的问题，通过hotspot中两个survivor设计得到解决
- 老年代
    特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁
    这种情况存在大量存活率高的对象，复制算法不适合。一般由标记-清除活着标记-整理的混合实现
    Java的老年代采用的是标记-清除算法
        -> Mark阶段的开销和存活对象的数量成正比
        -> Sweep阶段的开销与所管理区域的大小成正相关
        -> Compact阶段的开销与存活对象的数据成正比
        
# 分区算法
一般来说，堆空间越大，一次GC所需的时间越长，有关GC产生的停顿越长。为了更好控制GC产生的停顿时间，
将一块内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC产生的停顿

分区迭代算法按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间

每个小区间都独立使用，独立回收、这种算法的好处是可以控制一次回收多少个小区间
    
    


          