# 1，一条sql是怎么执行的？
1，建立连接：客户端发送请求到服务端
2. 查询缓存：对SQL更新的表，让其所对应的的查询缓存失效
3. 解析器：对SQL语句进行语法分析，校验关键字是否合规
4. SQL优化：选择索引，生成执行计划
5. 执行引擎：执行引擎去存储引擎查询需要更新的数据
6. 存储引擎：判断当前缓冲池中是否存在需要更新的数据，存在就直接返回，否则去磁盘加载数据
7. 调用：执行引擎调用存储引擎API去更新数据
8. 存储引擎执行：更新数据，写入undo_log、redo_log信息
9. 写binlog，执行引擎写binlog，提交事务，流程结束。
# 为什么有了docker还会有Kubernetes
Docker提供容器的生命周期管理和Docker镜像构建运行时容器。它的主要作用是将应用程序运行时所需的依赖打包到一个容器中，从而实现了可移植性的优点。
但是Docker作为单一的容器技术，我们在生产环境中，往往会有大规模的容器化部署。
而Docker难以支撑大规模容器化部署的要求，所以就有了Kubernetes。
Kubernetes可以对大规模容器进行组织和管理。在Docker的基础上，为容器化的应用提供部署、动态伸缩和负载均衡等一系列完整功能，提高了大规模容器集群管理的便捷性
# Synchronized与ReentrantLock区别
也就是所谓的显式锁和隐式锁（Synchronized和ReentrantLock）
1，原始构成：
    sychronized是java中的关键字，是由jvm来维护的，是jvm层面的锁
    lock是jdk5以后才出现的具体类。是API层面的锁
2，使用方法上：
    sychronized不需要手动释放锁，当同步代码块执行完毕后，系统自动让线程释放对锁的占用
    lock需要手动释放锁
3，等待是否可中断
    Sync是不可中断的。除非抛出异常或者正常运行完成
    Lock可以中断的。中断方式：
        1：调用设置超时方法tryLock(long timeout ,timeUnit unit)
        2：调用lockInterruptibly()放到代码块中，然后调用interrupt()方法可以中断
4，加锁的时候是否可以公平
    Sync：非公平锁
    lock：两者都可以的。默认是非公平锁。在其构造方法的时候可以传入Boolean值。
    true：公平锁；false：非公平锁
5，唤醒方式
    Sync:要么随机唤醒一个线程；要么是唤醒所有等待的线程。
    Lock:可以分组唤醒他们需要唤醒的线程，可以精确唤醒
# Seata
# 服务降级与服务熔断区别
# 灰度发布
灰度发布的原理其实就是对请求进行分流，可以让指定的用户访问指定的具有新功能的服务，其他的用户还是使用老的服务。既然是对请求进行分流，那么这个还是可以在 API 网关中统一处理，网关是对外的入口，当用户的请求过来时，我们可以将特定的用户请求转发到我们刚刚发布好的具有新功能的服务上去。

核心点还是在转发上做文章，那么就必须要对 Ribbon 进行改造了，因为 Zuul 中使用 Ribbon 来发现需要转发的实例，要想实现请求的分流来做灰度发布，就必须改造 Ribbon，不是改造源码，开源的框架扩展性都非常好，Ribbon 已经为我们提供了一个非常方便的扩展，就是自定义负载均衡策略，通过自定义负载均衡策略我们就可以在里面加上灰度发布的逻辑。

灰度发布只是在系统需要发布新功能时才会用到，并且需要轮流切换，首先将 A 机器上的服务变成灰度发布的状态，隔离所有请求，然后重新发布，验证好了之后重新发布另外机器上的服务。需要用到我们的 Apollo 配置中心来管理需要进行灰度发布的服务信息以及用户信息，这样才可以做到轮流切换。

总结下来我们只需要实现两点就可以达到灰度发布的效果，分别是：

1）将灰度的服务从正常的服务中移除，这样 Ribbon 在进行 Server 选择的时候就不会选择到已经被设置成灰度发布的 Server。

2）获取当前请求的用户 ID，如果这个用户是我们已经配置成灰度发布用户中的一员，那就从所有可用的服务中去对比灰度发布的服务，能找到那就直接返回，这样就能针对指定的用户使用我们配置的灰度服务了。
http://c.biancheng.net/view/5551.html
# mysql分库分表策略和出现的问题
1，事物一致性的问题
解决1：分布式事物
    当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分⽚事务也是分布式事务，没有简单的⽅案，⼀般可使⽤"XA协
    议"和"两阶段提交"处理。
解决2：最终一致性
    对于那些性能要求很⾼，但对⼀致性要求不⾼的系统，往往不苛求系统的实时⼀致性，只要在允许的时间段内达到最终⼀致性即可，可采⽤事务补偿的⽅式。
    与事务在执⾏中发⽣错误后⽴即回滚的⽅式不同，事务补偿是⼀种事后检查补救的措施，⼀些常见的实现⽅法有：对数据
    进⾏对账检查，基于⽇志进⾏对⽐，定期同标准数据来源进⾏同步等等。事务补偿还要结合业务系统来考虑
2，跨节点关联join的问题
    切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。⽽切分之后，数据可能分布在不同的节点上，此时join带来的问题就⽐较⿇烦了，考虑到性能，尽量避免使⽤join查询。
    解决1：全局表
        全局表，也可看做是"数据字典表"，就是系统中所有模块都可能依赖的⼀些表，为了避免跨库join查询，可以将这类表在每个数据库中都保
        存⼀份。这些数据通常很少会进⾏修改，所以也不担⼼⼀致性的问题。
    解决2：字段冗余
        ⼀种典型的反范式设计，利⽤空间换时间，为了性能⽽避免join查询。例如：订单表保存userId时候，也将userName冗余保存⼀份，这样
        查询订单详情时就不需要再去查询"买家user表"了
    解决3：数据组转
        在系统层⾯，分两次查询，第⼀次查询的结果集中找出关联数据id，然后根据id发起第⼆次请求得到关联数据。最后将获得到的数据进⾏字段拼装。
3，、跨节点分页、排序、函数问题
    跨节点多库进⾏查询时，会出现limit分页、order by排序等问题。分页需要按照指定字段进⾏排序，当排序字段就是分⽚字段时，通过分⽚
    规则就⽐较容易定位到指定的分⽚;
    ;当排序字段⾮分⽚字段时，就变得⽐较复杂了。需要先在不同的分⽚节点中将数据进⾏排序并返回，然后
    将不同分⽚返回的结果集进⾏汇总和再次排序
# 消息队列的作用
流量削峰
# SpringBoot的优点
1、独立运行Spring项目
    Spring boot 可以以jar包形式独立运行，运行一个Spring Boot项目只需要通过java -jar xx.jar来运行。
2、内嵌servlet容器
    Spring Boot可以选择内嵌Tomcat、jetty或者Undertow,这样我们无须以war包形式部署项目。
3、提供starter简化Maven配置
    spring提供了一系列的start pom来简化Maven的依赖加载，例如，当你使用了spring-boot-starter-web，会自动加入如图5-1所示的依赖包。
4、自动装配Spring
    SpringBoot会根据在类路径中的jar包，类、为jar包里面的类自动配置Bean，这样会极大地减少我们要使用的配置。当然，SpringBoot只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean，而SpringBoot灭有提供支持，则可以自定义自动配置。
5、准生产的应用监控
    SpringBoot提供基于http ssh telnet对运行时的项目进行监控。
6、无代码生产和xml配置
    SpringBoot不是借助与代码生成来实现的，而是通过条件注解来实现的，这是Spring4.x提供的新特性。
# mysql设计一个表的时候应该注意什么？
1，一定要整形ID作为主键
2，更小的通常更好 控制字节长度
3，使用合适的数据类型
    如tinyint只占8个位，char(1024)与varchar(1024)的对比,char用于类似定长数据存储比varchar节省空间，如：uuid（32），可以用char(32).
4，尽量避免NULL建议使用NOT NULL DEFAULT
    NULL的列会让索引统计和值比较都更复杂。可为NULL的列会占据更多的磁盘空间，在Mysql中也需要更多复杂的处理程序
5，为经常需要排序、分组和联合操作的字段建立索引
    经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间
6，常作为查询条件的字段建立索引
7，数据少的地方不必建立索引，建立索引会耗费一定的内存，如status字段一般值较少，就不建议添加索引

# 怎么调优接口
1，数据库层面的优化
2，代码重构
3，增加缓存
4，异步编排

# 设计接口需要注意什么

# 为什么TCP连接需要3次握手
什么是tcp协议：
    tcp协议是一种可靠的、基于字节流的、面向连接的传输层协议
握手过程其实就是建立这个可靠连接的过程：
    1，客户端向服务端发送连接请求并且携带客户端同步序列号syn
    2，服务端收到请求后发送服务端同步序列号syn和ack给客户端
    3，客户端收到服务端请求之后再次发送ack给服务端，以表明收到了服务端的请求
原因：
    1，tcp协议双方必须维护一个序列号，去标记已经发出去的数据包哪些是被对方签收的
    而三次握手就是通信双方相互告知序列号的起始值，为了确保这个序列号被收到，所以双方都需要一个确认操作
    2，tcp需要在不可靠的网络环境下，实现一个可靠的数据传输通道，而3次握手是建立这个通道的最小值
    3，防止重复连接初始化造成的网络混乱的问题。比如网络比较差的情况下，假设只有两次握手。
    那么服务端只能选择拒绝或者接受这个连接请求，但是服务端不知道这个请求是不是因为网络拥堵过期的请求


# redis连接地址写的是ip，如果主节点挂了，切换为副节点，那么此时这个ip地址怎么处理？
# redis的hash槽位是在什么地方进行计算的
# 分布式环境下的日志记录
# dependencyManagement有什么作用
使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；
如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。
# https为什么安全
# jwt的安全问题
# jwt组成
1.Header(头）作用：记录令牌类型、签名算法等 例如：{“alg":"HS256","type","JWT}
2.Payload(有效载荷）作用：携带一些用户信息 例如{"userId":"1","username":"mayikt"}
3.Signature(签名）作用：防止Token被篡改、确保安全性 例如 计算出来的签名，一个字符串
# ReentrantLock是如何刮起线程的
# Nginx在哪一个阶段执行了缓存的代码

# 虚拟机大小一半设置多少
# 频繁触发full gc原因
1，系统承载高并发请求，或者处理数据量过大，导致Young GC很贫乏，而且每次Young GC过后存活对象太多，
内存分配不合理，Survivor区过小，导致对象频繁进入老年代，频繁触发Full GC。
2，系统一次性加载过多数Sentinel据进内存，搞出来很多大对象，导致频繁有大对象进入老年带，必然频繁触发Full GC。
3，系统发生了内存泄漏，莫名其妙创建大量的对象，始终无法回收，一直占用在老年代里，必然频繁触发Full GC。
4，Metaspace（永久代）因为加载类过多触发Full GC。
5，误调用System.gc()触发Full GC。
# 线程池装饰
# 父线程怎么向子线程传参
# Spring线程池
# mybatis的二级缓存和一级缓存到底什么关系
Mybatis默认开启了一级缓存，但是它的一级缓存的作用域是同一个SqlSession对象，就是说只有当两个sql语句完全一样，并且都是通过同一个SqlSession对象操作数据库的时候，MyBatis的一级缓存才会生效
当执行一个和前面完全一样的sql语句的时候，这样就不会重新连接数据库从磁盘中取数据了，而是从一级缓存中（内存中）直接取数据。
但是一级缓存不实用，因为我们调用同一个动态代理接口方法的时候，每次调用一个方法无论相同不相同都会重新创建一个SqlSession对象。
（
这里的描述是不对的，真正的原因是Spring集成Mybatis后，Spring将MyBatis的DefaultSqlSession类替换成了SqlSessionTemplate。
在没有添加@Transactional注解的情况下，每调用一次查询SQL，就会通过SqlSessionTemplate去创建sqlSession，即相当于新创建一次连接，故而每次查询在调试结果看来就是一级缓存失效
这层封装主要是集成了Spring的事物，
）
二级缓存主要是用在分布式和多线程的情况下，不同的线程访问，那么sqlsession肯定是不一样的
# Spring中的源码
# AIO
# 链路追踪和日志模块
# spring中的
# 熔断和降级有什么区别
服务熔断
    作用类似于保险丝，当服务不可用或响应超时的情况，为了防止整个系统崩溃，暂时停止对该服务的调用
服务降级
    是从整个系统的负荷情况出发和考虑的，对某些负荷比较高的情况，为了预防某些功能出现负荷或者响应慢的情况，在其内部舍弃一些非核心接口和数据的请求
    而直接返回一个提前准备好的fallback错误处理信息。这样虽然提供的是一个有损的服务，但保证了整个系统的稳定性和可用性
服务限流
# 什么时候需要分库什么时候需要分表
仅当数据库连接数不够用的情况下，采用分库的方式来提高数据库性能瓶颈
仅当单表存储数据量超过500w或者单表大小超过2G的时候，采用分表的形式来提高表的读和写的瓶颈
当上面两种情况同时出现的时候，就是需要考虑分库分表的时候。
# 分库分表策略


# zookeeper分布式锁
# JWT和传统session/cookie有什么区别
# JWT如何防止被篡改
# 库存+1有没有不使用version的更好的解决方案
# ABA的问题基本数据类型和对象有影响么
# ABA的问题对库存有影响么
# 分布式cookie
首先要了解Cookie作用域，这里就用到了cookie的两个属性 domain，path。当请求与cookie的域名相同且作用路径相同的时候，浏览器才会携带cookie才可以实现cookie共享
# 
