# 二叉查找树
二叉查找树也称为有序二叉查找树，满足二叉树的一般性质
1，每个节点最多有两个子树，可以没有子树或者一个子树
2，左子树和右子树有顺序，次序不能任意颠倒
3，即使某个节点只有一颗子树，也要区分是左子树还是右子树
4，没有键值相等的节点
5，任意节点左右子树不能为空，则左子树的值小于跟节点的值，右子树的值大于跟节点的值

局限性
如果我们的跟节点选择是最小或者最大的树，那么二叉树就退化成了线性结构

# avl树
avl树是带有平衡条件的二叉查找树，通过平衡因子差值判断是否平衡，通过旋转来实现平衡，左右子树树高不超过1，是严格的平衡二叉树
不管我们执行插入还是删除操作，只要不满足左右子树高度差值，就通过旋转来保持平衡，而旋转是非常耗时的，由此我们知道avl树适合插入删除次数少，但是查找多的情况
平衡因子的算法：右子树高度-左子树高度

应用
Windows NT内核中广泛存在

# 红黑树
一种二叉查找树，但是每个节点增加一个存储位表示节点颜色，或者red或者black。通过对任何一条从根到叶子的路径上哥哥节点着色的方式限制。
红黑树确保没有一条路径会比其他路径长出两倍。它是一种弱平衡的二叉树（由于是弱平衡，可以推出相同节点下avl树的高度低于红黑树），
相对于要求严格的avl树来说，它的旋转次数少，所以对于搜索、插入、删除操作多的情况下，就使用红黑树

主要解决

红黑树其实是2-3树
一般我们接触最多的是二叉树，也就是一个父节点最多有两个子节点。2-3树一个父节点可以有两个子节点，也可以有三个子节点
最重要的性质：2-3树所有子节点都在同一层，且最后一层不能有空节点，类似于满二叉树

怎么将红黑树改造成二叉树呢？
1，对于2节点，保持不变，对于三节点，
2，首先将3节点中左侧的元素标记为红色
3，再将3节点位于中间的子节点，更改它的父节点为红色节点
然后就是大名鼎鼎的红黑树了......
性质1：每个节点要么是黑色，要么是红色
    2-3树中存在2节点和3节点，3节点中左侧的元素便是红色，而其他节点是黑色
性质2：跟节点是黑色
    2-3树中，跟节点只能是2节点或者3节点，但是无论是2接节点还是3节点，跟节点都是黑色
性质3：每个叶子节点(nil)都是黑色
    这里的叶子结点不是指左右子树为空的那个叶子结点，而是指节点不存在子节点或者空节点成为叶子结点。
    在性质2中我们讨论的跟节点是黑色的都是讨论跟节点不为空的情况，若红黑树是一个空树，那么跟节点自然也是空的叶子结点，这时候叶子结点必然是黑色
性质4：每个红色节点的两个子节点一定是黑色
    从2-3树角度理解，红色节点对应2-3树中3节点最左侧元素，那么它的子节点无论是2节点还是3节点对应的节点颜色都是黑色
性质5：任意节点到每个叶子结点的路径包含相同数量的黑节点
    这应该是红黑树最重要的性质了，2-3树是一颗绝对平衡树，即2-3树中任意一个节点出发，到达叶子节点后所经过的节点数都是一样的
https://blog.csdn.net/weixin_39642998/article/details/111094248

红黑树的自我修正：
    1，改变节点颜色
    2，左旋转
        逆时针旋转红黑树的两个节点，使父节点被自己的右孩子取代，成为自己的左孩子
    3，右旋转
        顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，成为自己的右孩子

性质
1，跟节点是黑色
2，每个节点非红即黑
3，红色的节点，它的叶子节点只能是黑色
4，每个叶节点（叶节点即树尾端NUll指针或NUll节点）都是黑
    有的文章会说所有叶子节点都是黑色的，有的文章不会说。对于说所有叶子都是黑的文章，它所说的叶子其实是人为加上去的，一般会标记为 nil，并不是实际存在的节点，只是为了方便我们理解（旋转那里）而已。
5，对于任意节点，其到叶子结点树null指针的每条路径都包含相同数目的黑节点

应用
1，广泛应用于c++的stl中，map、set都是用红黑树实现
2、著名的Linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间； 
3、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查； 
4、Nginx中用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器； 
5、Java中TreeMap的实现；

# B树
B/B+树是为了磁盘或其他存储设备而设计的一种平衡多路查找树（相对于二叉，B树每个内节点有多个分支），于红黑树相比
在相同节点的情况下，一颗B/B+树的高度远远小于红黑树的高度

特点
1，所有的键值分布在整颗树中
2，搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找
3，每个节点最多拥有m个子树
4，跟节点至少有两个子树
5，分支节点至少拥有m/2颗子树（除跟节点和叶子结点外都是分支节点）
6，所有叶子结点都在同一层、每个节点做多可以有m-1个key，并且以升序排列

性质
1、定义任意非叶子结点最多只有M个儿子，且M>2； 
2、根结点的儿子数为[2, M]； 
3、除根结点以外的非叶子结点的儿子数为[M/2, M]； 
4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 
5、非叶子结点的关键字个数=指向儿子的指针个数-1； 
6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]； 
7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 
8、所有叶子结点位于同一层； 

# B+树
B+树是应文件系统产生的一种B树的变形树，非叶子结点只保存索引，不保存实际数据，数据都保存在叶子节点
我们就举个文件查找的例子：有3个文件夹a、b、c， a包含b，b包含c，一个文件yang.c，a、b、c就是索引（存储在非叶子节点）， a、b、c只是要找到的yang.c的key，而实际的数据yang.c存储在叶子节点上。
所有的非叶子节点都可以看成索引部分！

性质
1、非叶子节点的子树指针与关键字个数相同； 
2、非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)； 
3、为所有叶子节点增加一个链指针； 
4、所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)； 
5、非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层； 
6、更适合于文件系统；

应用
1、B和B+树主要用在文件系统以及数据库做索引，比如MySQL；