# 创建对象方式
- new：最常见的方式
- class的newInstance：反射的方式，只能调用空参构造器，权限必须是public
```
/*通过Class.NewInstance()创建新的类示例*/   
    private void newInstanceByClassNewInstance(){   
        try {/*当前包名为reflect，必须使用全路径*/   
            A a=(A)Class.forName("reflect.A").newInstance();   
        } catch (Exception e) {   
            out.println("通过Class.NewInstance()调用私有构造函数【失败】");   
        }  
    }
```
- Constructor的newInstance(Xxx)：反射的方式，可以调用空参、带参构造器，权限没有要求
```
/*通过Constructor.newInstance()创建新的类示例*/   
    private void newInstanceByConstructorNewInstance(){   
        try {/*可以使用相对路径，同一个包中可以不用带包路径*/   
            Class c=Class.forName("A");   
            /*以下调用无参的、私有构造函数*/   
            Constructor c0=c.getDeclaredConstructor();   
            c0.setAccessible(true);   
            A a0=(A)c0.newInstance();   
            /*以下调用带参的、私有构造函数*/   
            Constructor c1=c.getDeclaredConstructor(new Class[]{int.class,int.class});   
            c1.setAccessible(true);   
            A a1=(A)c1.newInstance(new Object[]{5,6});   
        } catch (Exception e) {   
            e.printStackTrace();   
        }   
    }
```
- 使用clone：当前类要实现Cloneable接口
- 使用反序列化：从文件中、从网络中获取一个对象的二进制流
- 第三方库：Objenesis

# 对象实例化
1，加载对象的元信息
（虚拟机遇到一条new命令，首先检查这个指令参数是否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析、初始化。即判断元信息是否存在）
2，为对象分配内存
3，处理并发安全问题
   -> 采用CAS失败重试，区域加锁保证更新原子性
   -> 每个线程分配一个TLAB
4，默认属性初始化
5，设置对象头信息
6，显式初始化、代码块中初始化、构造器中初始化

# 对象的内存布局
1，对象头
   -> 运行时元数据（哈希地址值、GC分代年龄、锁状态标志、线程持有的锁、偏向锁、偏向时间戳）
   -> 类型指针（指向元空间，确定对象所属类型）
2，实例数据
即对象真正存储的有效信息，包括代码中定义的各种类型字段（从父类继承下来的和本身拥有的）

# 对象访问定位
1，句柄访问
2，