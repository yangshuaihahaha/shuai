# 1， 整体架构图
1，nginx集群访问项目
2，进入webflux网关（使用的是springcloud gateway），网关根据请求动态路由到指定的服务
如果一个结构在好几个请求里面都存在，那么也可以通过ribbon进行负载均衡
如果服务出现问题使用sentinel进行服务熔断降级，限流
网关还进行认证授权
3，当请求到达微服务集群，集群使用feign进行相互调用。
微服务登陆校验使用的是spring security Oauth2
配置中心和注册中心都是nacos

除了一般的登陆还集成了社交登陆
4，缓存用的是redis的分片集群和哨兵集群
5，持久化用的是mysql集群，有读写分离，和独库独表
6，使用rabbitmq消息队列
7，全文检索ES
8，图片存储用的是oss
9，日志存储用的是ELK（ES、kibana、LogStash）
10，服务追踪（sleuth、zipkin、metrics）交给promethrus进行聚合分析，再由grafana进行可视化展示，
同时promethrus还会有告警信息发送邮件
11，使用kuberneturs集成

# 2，前期服务搭建
可以使用vagrant来初始化一个centos镜像，结合virtual VM来使用
vagrant init centos//初始化
vagrant up//生成或者启动虚拟机
vagrant ssh//连接虚拟机
虚拟机网络配置：
    启动之后可以通过配置Vagrantfile这个文件来中的 config.vm.network "private_network", ip: "192.168.33.10"
    来解决端口转发的问题

然后使用docker安装mysql
docker之间的容器是相互隔离的，每个镜像都相当于一个小的linux环境

docker run -p 3306:3306 -name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7

这是用来启动mysql的
-p 3306:3306 将容器的3306端口映射到主机的3306端口
/mydata/mysql/log:/var/log/mysql ： 将日志文件挂载到主机
/mydata/mysql/data:/var/lib/mysql ：将数据文件挂载到主机
/mydata/mysql/conf:/etc/mysql ：将配置文件挂在到主机

redis也一样需要将一些文件挂载到虚拟机服务器

# 快速开发人人开发搭建后端开发平台
主要有的微服务是
    gulimall-coupon
    gulimall-member
    gulimall-order
    gulimall-producr
    gulimall-ware
    gulimall-common //用来存放公用的类，公共依赖
然后使用
    renren-fast搭建管理系统的后端
    renren-fast-vue搭建管理系统的后端
    renren-generator生成各个微服务的基本代码
    
# 微服务的nacos注册中心
1，下载并启动nacos服务器 
2，引入nacos依赖，到公共模块gulimall-common
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
3，在application.properties配置nacos的端口号和地址
    spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
4，在入口使用@EnableDiscoveryClient注解启用nacos
    @SpringBootApplication
    @EnableDiscoveryClient
    public class NacosProviderDemoApplication {
       public static void main(String[] args) {
           SpringApplication.run(NacosProducerDemoApplication.class, args);
       }
       @RestController
       public class EchoController {
           @GetMapping(value = "/echo/{string}")
           public String echo(@PathVariable String string) {
               return "Hello Nacos Discovery " + string;
           }
       }
    }

# 测试会员服务调用优惠券服务
1，概述
获取某个会员所有的优惠券
会员服务（gulimall-member）去注册中心nacos找一下优惠券服务（gulimall-coupon）在那一些机器，得到机器后挑一台机器发送请求来获取数据
服务之间远程点用使用的是feign

2，什么是feign
feign是一个声明式的http客户端，它的目的就是让远程调用更简单。feign提供了http请求的模版，通过编写简单的接口和注解插入，
就可以定义好http请求参数、格式、地址等信息
feign整合了ribbon（负载均衡）和hystrix（服务熔断），可以让我们不需要显式的使用这两个组件
springcloudfeign在netflixfeign的基础上扩展了对springmvc注解的支持，在其实现下，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方接口绑定
简化了springcloudribbon自行封装服务调用客户端的开发量

2，feign使用
(1) 引入依赖open-feign
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactid>spring-cloud-starter-openfeign</artifactid>
    </dependency>
(2) 编写一个接口表示需要调用远程服务(在gulimall-member中编写)
    @FeignClient("gulimall-coupon")
    public interface CouponFeignService {
        @RequestMapping("/coupon/coupon/member.list")
        public R membercoupons();
    }
(3) 开启feign
    @EnableFeignClients(basePackages="com.atguigu.gulimall.member.feign")
    @SpringBootApplication
    @EnableDiscoveryClient
    public class GulimallMemberApplication {
       public static void main(String[] args) {
           SpringApplication.run(GulimallMemberApplication.class, args);
       }
    }
    
# nacos作为配置中心
bootsreap.properties会优先于application.properties加载
1，导入依赖
    <dependency>
        <groupId>org.alibaba.cloud</groupId>
        <artifactid>spring-cloud-starter-alibaba-nacos-config</artifactid>
    </dependency>
2，在应用/src/main/resources/bootsreap.properties配置文件中配置Nacos Config元数据
    spring.application.name=gulimall-coupon //名字
    spring.cloud.nacos.config.server-addr=127.0.0.1:8848 //nacos服务器地址
3，需要给配置中心默认添加一个叫 数据集 gulimall-coupon.properties（应用名.properties）
    然后就可以在nacos的服务端添加gulimall-coupon.properties添加配置信息
    对应的controller加上@RefreshScope 来动态获取并刷新配置
    @Value("${配置项}")来获取配置
    如果配置中心和当前应用的配置文件都配置了相同项，优先使用配置中心的配置
    细节
        (1) 命名空间
            做环境隔离（dev、test、prod）
                gulimall-coupon.properties默认是在public（保留的命名空间）里面，但是如果我们有开发、测试、生产环境那么怎么能用同一个呢？
                我们可以在nacos服务端配置中心配置多个命名空间test、dev、prod。在不同的命名空间下面创建gulimall-coupon.properties
                然后在对应微服务bootsreap.properties的配置文件配置，指定对应的命名空间
                    spring.cloud.nacos.config.namespace=6b31e642-4adb-449e-a038-314c5934b564
            微服务之间的相互配置隔离，每个微服务都有自己创建的命名空间  
        (2) 配置组  
             新增的配置文件都有一个组别，比如双十一的时候就用1111分组，618的时候用618分组
             在bootsreap.properties加上spring.cloud.nacos.config.group=1111来配置分组
        建议使用：为每个微服务创建自己的命名空间，使用配置分组来区分dev、test、prod
        (3) 加载多个配置文件
            我们把所有的文件放在一个配置文件中会显得凌乱，所以需要分开存放多个配置文件，比如datasource.ymc、mybaties.properties等等这样的话怎么来加载这些配置文件呢？
            spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml
            spring.cloud.nacos.config.ext-config[0].group=dev
            spring.cloud.nacos.config.ext-config[0].refresh=true

# 关于gateway
网关作为流量的入口，常用的功能包括路由转发、权限校验、限流控制等。而Springcloud Gateway作为 springcloud官方推出的第二代网关框架，取代了zull网关

基本流程就是请求到达网关，网关根据断言判断路由是否符合规则， 如果符合了路由到指定的服务器，当然这中间会经过一系列的filter

网关使用的是netty做的而不是tomcat

需要单独创建一个单独的module，gulimall-gatway，然后依赖common工程
然后开启服务注册发现，配置注册中心地址，配置中心地址
    @EnableDiscoveryClient
    @SpringBootApplication
    public class GulimallGatewayApplication {
        public static void main(String[] args) {
            SpringApplication.run(GulimallGatewayApplication.class, args);
        }
    }

然后在这个工程下面创建application.yml文件，并进行配置
spring:
    cloud:
        gatwey:
            routes:
                - id: baidu_route
                  uri: https://www.baidu.com
                  predicates:
                    - Query=url,baidu
                - id: qq_route   
                  uri: https://www.qq.com
                  predicates:
                    - Query=url,qq 

# 前端vue
```html
<div id='app'>
    <!--事件处理-->
    <button v-on:click="num++">点赞</button>
    <button v-on:click="cancle">取消</button>
    <!--双向绑定-->
    <input type="text" v-model="num"/>
    <!-- 声明式渲染-->
    <h1>{{name}}, 非常帅, 有{{num}}为他点赞</h1>
    <!--html原生显示和解析显示-->
    <span v-html="msg"></span>
    <span v-text="msg"></span>
    <!--给html属性绑定-->
    <a v-bind:href="link">gogogo</a>
    <!--class,style-->
    <span v-bind:class="{active:isActive,'text-danger':hasError}">你好</span>
    <span v-bind:style="{color:color1,'font-size':fontSize1}">你好</span>
    
    <!--表单项-->
    精通的语言：
        <input type="checkbox" v-model="" value="java"/> java<br/>
        <input type="checkbox" value="php"/> php<br/>
        <input type="checkbox" value="python"/> php<br/>
    选中了{{language.join(',')}}


    <!--阻止事件冒泡和默认事件-->
    <!--大div只点击一次-->
    <div @click.once="hello">
        <!--阻止事件冒泡-->
        <div @click.stop="hello">
            <!--阻止默认事件发生-->
            <a href="http://www.baidu.com" @click.prevent>去百度</a>
            <!--阻止默认事件后执行hello-->
            <a href="http://www.baidu.com" @click.prevent="hello">去百度</a>
            <!--阻止默认事件发生，阻止冒泡后执行hello-->
            <a href="http://www.baidu.com" @click.prevent.stop="hello">去百度</a>
        </div>
    </div>
    


    <!--按键修饰符-->
    <input type="text" v-model="num" v-on:keyup.up="num+=2" @keyup.down="num-=2" @click.ctrl="num=10" />



    <!--遍历循环-->
    <ul>
        <li v-for="user in users">
            {{user.name}}
        </li>
    </ul>
    <!--获取下标-->
    <ul>
        <li v-for="(user,index) in users" :key="user.name">
            {{user.name}} - {{index}}
            <span v-for="(v, k, i) in user">
                {{k}} ------ {{v}} ------ {{i}}
            </span>
        </li>
    </ul>
    <!--建议在遍历的时候，都设置一个key，提高遍历渲染效率！！！
        key值是不可重复的，如果没有合适的值就设置为角标index-->
    <ul>
        <li v-for="(num, index) in nums" :key="index">
            {{num}}
        </li>
    </ul>
    
    <!--条件判断-->
    <button @click="show = !show"></button>
    <h1 v-if="show">if - 显示</h1>
    <h1 v-show="show">show - 显示</h1>
    
    <h1 v-if="random>1">random大于1</h1>
    <h1 v-else-if="random>2">random大于2</h1>
    <h1 v-else-if="random>3">random大于3</h1>
    <h1 v-else>大于4</h1>

    <!--计算属性-->
    <ur>
        <li>西游记，价格：{{xyjPrice}}, 数量：<input type="number" v-model="xyjNum"></li>
        <li>水浒传，价格：{{shzPrice}}, 数量：<input type="number" v-model="shzNum"></li>
        <li>总价：{{totalPrice}}</li>
    </ur>

    <!--过滤器-->
    <ul>
        <li v-for="user in users" :key="user.name">
            <!--管道过滤器-->
            {{user.name}} --  {{user.gender | genderFilter}}
            {{user.name}} --  {{user.gender | gFilter}}
        </li>
    </ul>
</div>
<script>
Vue.filter('gFilter', function(val) {
    if (val == 1) {
        return "男";
    } else {
        return "女";
    }
})
let vm = new Vue({
    el: '#app',
    data: {
        name:'张三',
        num: 1,
        msg: '<h1>Hello</h1>',
        link: 'http://www.baidu.com',
        isActive: true,
        hasError:true,
        color1: red,
        fontSize1: 80px,
        language: [],
        xyjNum: 1,
        shzNum: 1
    },
    methods: {
        cancle() {
            this.num--;
        },
        hello() {
            alert('hello')
        },
        // 计算属性
        computed: {
            totalPrice() {
                return this.xyjPrice*this.xyjNum + this.shzPrice*this.shzNums
            }       
        },
        // 监听器
        watch: {
            xyjNum: function(newval, oldval) {
                if (newval > 3) {
                   alert(newval + "-" + oldval);
                }                 
            }
        }  
        // 过滤器
        filters: {
            genderFilter(val) {
                if (val == 1) {
                    return "男";
                } else {
                    return "女";
                }
            }
        }   
    }
})
</script>



<!--vue组件化-->
<div id="app">
    <button v-on:click="count++">我被点击了 {{count}} 次</button>
    <counter></counter>
    <button-counter></button-counter>
</div>
<script>
    //1,全局声明注册一个组件
    Vue.component('counter', {
        template: `<button v-on:click="count++">我被点击了 {{count}} 次</button>`,
        data() {
            return {
                count: 1
            }
        }
    })
    //1,局部声明注册一个组件
    const buttonCounter = {
        template: `<button v-on:click="count++">我被点击了 {{count}} 次</button>`,
        data() {
            return {
                count: 1
            }
        }
    }
    Vue.component('counter', {
        template: `<button v-on:click="count++">我被点击了 {{count}} 次</button>`,
        data() {
            return {
                count: 1
            }
        }
    })
    new Vue({
        el: '#app',
        data: {
            count: 1
        },
        components: {
            'button-counter': buttonCounter
        }
    })
</script>


<!--vue声明周期-->
<div id="app">
    <span id="num">{{num}}</span>
    <button @click="num++">赞</button>
    <h2>{{name}}, 有{{num}}个人点赞</h2>
</div>
<script>
    new Vue({
        el: '#app',
        data: {
            name: '张三',
            num: 100
        },
        method: {
            show(){
                return this.name
            },
            add() {
                this.num++
            }
        },
        beforeCreate() {
            console.log("数据模型未加载");
            console.log("方法未加载");
            console.log("方法未加载");
        },
        created() {
            console.log("数据模型已加载");
            console.log("方法已加载");
            console.log("html模版已加载");
            console.log("html模版未渲染");
        },
        beforeMount() {
            console.log("html模版未渲染");
        },
        mounted() {
            console.log("html模版已渲染");
        },
        beforeUpdate() {
            console.log("数据模型已更新");
            console.log("html模版未更新");
        },
        updated() {
            console.log("数据模型已更新");
            console.log("html模版已更新");
        },
    })
</script>
```

# 后台管理系统（renren-fast）配置网关路由和路径重写
运行起来后台管理系统后，需要将前端请求的地址发送给网关，由网关来进行负载负载均衡
gateway网关配置：
    spring:
        cloud:
            gatwey:
                routes:
                    - id: admin_route
                      uri: lb://renren-fast
                      predicates:
                        - Path=/api/**
                      filters:
                        - RewritePath=/api/(?<sagment>.*),/renren-fast/$\{segment}
lb://renren-fast: 
    lb表示的是负载均衡
- Path=/api/**: 
    表示这些请求都会走这个网关配置
- RewritePath=/api/(?<sagment>.*),/renren-fast/$\{segment}:
    表示重写路径，在路径前面加上/renren-fast

# 网关统一配置跨域
gulimall-gateway项目下增加一个CorsConfiguration来解决跨域
@Configuration
public class CorsConfiguration {
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod("*"); // 允许任何方法（post、get等）
        config.addAllowedOrigin("*"); // 允许任何域名使用
        config.addAllowedHeader("*"); // 允许任何头
        config.setAllowCredentials(true); //允许接受cookie
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);
        return new CorsWebFilter(source);
    }
}

# 配置商品服务（gulimall-product）网关
运行起来后台管理系统后，需要将前端请求的地址发送给网关，由网关来进行负载负载均衡
gateway网关配置：
    spring:
        cloud:
            gatwey:
                routes:
                    - id: admin_route
                      uri: lb://gulimall-product
                      predicates:
                        - Path=/api/product**
                      filters:
                        - RewritePath=/api/(?<sagment>.*),/$\{segment}
这个路由信息需要放在renren-fast前面，因为这是精确路由

# 结合renren-fast-vue书写三级分类菜单的查询


# 菜单删除，mybatis-plus逻辑删除
1，在application.yml配置全局的逻辑删除规则
    mybatis-plus:
        global-config:
            db-config:
                logic-delete-value:1
                lofic-not-delete-value:0
2，给bean的字段上加上逻辑删除注解
    @TableLogic(value="1", delval="0")
    private Integer showStatus;

# JSR303数据校验
1，给Bean添加校验注解：javax.validations.constraints
    @NotNull
    private String name;
    @NotNull("logo必须提交")//这里还可以自定义错误信息
    private String logo;
    @Pattern(regexp="/^[a-zA-Z]$", message="检索首字母必须是一个字母")//正则表达式
    private String description;
2，在controller上的save方法开启校验功能：@Valid
    @RequestMapping("/save")
    public R save(@Valid @RequestBody BrandEntity brand) {
        aService.save(brand)
    }
3，给校验的bean后紧跟一个BindingResult，就可以获取到校验的结果
    @RequestMapping("/save")
    public R save(@Valid @RequestBody BrandEntity brand, BindingResult result) {
        Map<String, String> map = new HashMap<>();
        if (result.hasErrores()) {
            result.getFieldErrors().foreach((item) -> {
                String message = item.getDefaultMessage();
                String field = item.getField();
                map.put(field, message);
            })
            return R.error(400, "提交的数据不合法").put("data", map)
            //提交的数据不合法
        } else {
            aService.save(brand)
        }
    }

# 统一异常处理
上面需要在每一个save请求都写一个BindingResult然后进行异常处理，这样是很冗余的
在每个微服务里面都建立一个统一的异常处理，集中处理异常
    @Sl4j
    @RestControllerAdvice(basePackages="com.atguigu.gulimall.product.controller")
    public class GulimallExceptionControllerAdvice {
        @ExceptionHandler(value=MethodArgumentNotValidException.class)
        public voided handleValidException(Exception e) {
            log.error("数据校验出现问题", e.getMessage(), e.getClass())
            BindingResult bindingResult = e.getBindResult();
            Map<String, String> errorMap = new HashMap<>();
            bindingResult.getFieldErrors().foreach((item) -> {
                            String message = item.getDefaultMessage();
                            String field = item.getField();
                            map.put(field, message);
                        })
            return R.error(400, "提交的数据不合法").put("data", errorMap)
        }
    }

# 封装统一的状态码
public enum BizCodeEnum {
    UNKONW_EXCEPTION(10000, "系统未知异常")
    VLILID_EXCEPTION(10001, "参数格式校验失败")
    private int code;
    private String msg;
    BizCodeEnum(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }
    private int getCode() {
        return this.code;
    }
    private int getMsg() {
        return this.msg;
    }
}
就可以这样返回
return R.error(BizCodeEnum.UNKONW_EXCEPTION.getCode(), BizCodeEnum.UNKONW_EXCEPTION.getMsg()).put("data", errorMap)

# JSR303分组校验
业务场景：新增的时候id为空，而编辑的时候id不为空
1,创建分组接口
    public interface AddGroup {}
    public interface UpdateGroup {}
1,增加group，标注什么情况下需要校验
    @NotNull(message="修改时id不能为空", groups={Update.class})
    @Null(message="新增时id为空", groups={AddGroup.class})
    @TableId
    private Integer id;
    
    @NotBlank(message="品牌名必须提交", groups={Update.class,AddGroup.class})
    @TableId
    private String name;
2,在controller指定校验分组:@Valid(Update.class)
    @RequestMapping("/save")
    public R save(@Valid(Update.class) @RequestBody BrandEntity brand, BindingResult result) {
        aService.save(brand)
    }
    
# JSR303自定义校验注解
1，编写一个自定义校验器
@Documented
@Constraint(validateBy = {ListValueConstrainValidator.class})
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
public @interface ListValue {
    String message() default "{java.validation.constraints.listvalue.message}";
    Class<?>[] groups() default {};
    CLass<?>[] groups() default {};
    CLass<? extends Payload>[] payload() default {};
    int[] values default {};
}
    
2，编写一个自定义校验器
public class ListValueConstrainValidator implements ContraintValidator<ListValue, Integer> {
    private Set<Integer> set = new HashSet<>()
    @Override
    public void initializa(ListValue contraintAnnotation) {
        //这里是传入的值
        int[] vals = contraintAnnotation.vals();
        for (int val : vals) {
            set.append(val);
        }
    }
    @Override
    public void isValid(Integer value, ConstraintValidatorContext context) {
        //value就是要校验的属性值
        return set.contains(value);
    }
}
3，关联自定义校验器和自定义校验注解

# SPU和SKU
SPU
SPU：Standard Product Unit，标准产品单位。

概念：SPU 是商品信息聚合的最小单位【即：商品共同的属性】，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。
通俗点讲，属性值、特性相同的货品就可以称为一个 SPU

SPU是用来定位的
例如：iphone8 就是一个 SPU，与商家、颜色、款式、套餐都无关

SKU
SKU：Stock Keeping Unit，库存量单位。

概念：SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。
在使用时要根据不同业务，不同管理模式来处理

SKU是用来定价和管理库存的
iphone8 有很多颜色，很多配置，每个颜色和配置的组合都会形成新的产品，这时就产生很多SKU
例如：银色 64G 的 iphone8 就是一个SKU；纺织品中一个 SKU 通常表示：规格、颜色、款式
    
# es整合springboot（使用lastic-Rest-Client）
单独创建一个gulimall-search，用于搜索
1，创建一个ES的客户端配置文件
@Configuration
public class GulimallElasticSearchConfig {
    public static final RequestOptions COMMON_OPTIONS;
    static {
        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();
        builder.addHeader("Authorization", "Bearer " + TOKEN); 
        builder.setHttpAsyncResponseConsumerFactory(           
            new HttpAsyncResponseConsumerFactory
                .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));
        COMMON_OPTIONS = builder.build();
    }
    @Bean
    public RestHighLevelClient esRestClient() {
        return new RestHighLevelClient(RestClient.builder(new HttpHost("127.0.0.1", 9200, "http")));
    }
}
2，测试保存
@Test
public void indexData() {
    IndexRequest indexRequest = new IndexRequest('users');
    indexRequest.id("1");
    User user = new User();
    user.setName("张三")
    user.setGender("男")
    String jsonString = JSON.toJSONString(user);
    indexRequest.source(jsonString, XContentType.JSON);//需要保存的内容
    //执行操作
    IndexResponse index = client.index(indexRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);
}
3，测试检索复杂数据
@Test
public void searchData() {
    SearchRequest searchRequest = new SearchRequest(); 
    1，//指定索引
    searchRequest.indices("bank");
    2，//DLS，检索条件
    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); 
    searchSourceBuilder.query(QueryBuilders.matchAllQuery()); 
    searchRequest.source(searchSourceBuilder); 
    3，//执行检索
    SearchResponse searchResponse = client.search(searchRequest, GulimallElasticSearchConfig.DEFAULT);
    4，分析结果
}

# sku在es中的存储模型
点击上架就会上架商品，然后在es中生成商品的信息
sku和spu信息是一起存储的，可能会有冗余的字段，选择的是空间换取时间

如果想要解决这些冗余字段，就得选择时间换取空间，也就是先查询出sku信息在通过sku信息查询出spu信息
这样带来的问题就是二次查询sku信息过多时，请求超时严重。

比如我们查询苹果，得到的sku信息可能是手机、水果、食品有几十万条数据，再根据这几十万条数据去查询spu就会很慢
如果百万并发的话，还会造成服务器崩溃

# ngnix代理
    正向代理：
        类似一个跳板机，代理访问外部资源
        比如我们访问谷歌，访问不到，我们可以通过正向代理服务，把请求发送到代理服，代理服能够访问谷歌，这样由代理服访问谷歌，这样我们就能访问谷歌了
        应用场景：
            vpn访问谷歌，比如google
            可以做缓存访问资源
            客户端访问授权，上网进行认证
            代理可以记录用户访问记录，对外隐藏用户信息
    反向代理：
        实际上就是以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到结果返回给internet上请求连接的客户端
        主要用途：
            保证内网安全，组织web攻击，大型网站通常将反向代理作为公网地址，web服务器是内网
            负载均衡，通过反向代理服务器来优化网站的负载
    nginx.config
        全局块：配置影响nginx全局的指令。如：用户组、nginx进程pid存放路径、日志存放路径、配置文件引入、允许生成worker process数等
        events块：配置影响nginx服务器或与用户的连接。如：每个进程的最大连接数、选取哪一种事件驱动模型处理连接请求、是否允许多个网络连接、开启多个网络连接序列化
        http块：可以嵌套多个server，配置代理、缓存、日志等绝大多数功能以及第三方模块的配置。如文件引入、mime-type定义、日志自定义、是否使用sendfile传输文件、连接超时时间、单请求连接数
            http全局模块：错误页面、连接超时
                location：配置请求的路由以及各种页面的处理情况
                location：
                .........
                
    在这个商城项目中具体的应用：
        1，在nginx的总配置文件中使用upstream配置上游服务器地址
        http {
            upstream gulimall {
                server 192.168.56.1:88;//这里配置的是网关的地址
            }
        }
        2，在gulimall.conf的nginx中配置
        http {
            location / {
                proxy_set_header Host $host//这里如果不加在转发的时候会丢掉请求头，访问就会出错
                proxy_pass http://gulimall;//引用上游服务器地址
            }
        }
        3，在网关中配置路由规则（这一段一定放在最后，要不然前面的配置就会被路由）
        - id: gulimall_host_route
          uri: lb://gulimall-product
          predicates:
            - Host=**.gulimall.com,gulimall.com

# thymeleaf渲染首页
在product里面配置
1）配置关闭缓存
spring
    thymeleaf:
        cache:false
2）静态资源都放在static文件夹下就可以按照路径访问
3）页面放在templates下，直接访问

# 压力测试
    HPS：每秒点击次数，单位是次/秒
    TPS：系统每秒处理的交易数
    QPS：系统每秒处理查询次数
    对于互联网业务中，如果某些业务仅有一个请求连接，那么TPS=QPS=HPS，
    一般用TPS来衡量业务流程，用QPS来衡量接口查询次数，用HPS表示对服务器的单次请求
    一般情况下：
        金融行业：1000TPS-50000TPS，不包括互联网的活动
        保险行业：100TPS-1000000TPS，不包括互联网互动
        制造业：10TPS-5000TPS
        互联网电子商务：10000TPS-10000000TPS
    影响性能的考虑包括：
        数据库、应用程序、中间件（nginx、tomcat）、网络、操作系统等
        
    压测内容      压测线程数     吞吐量     90%响应时间     99%响应时间
    Nginx          50         2335        11              944
    Getway         50         10367       8               31
    简单服务        50         11341       8               17
    首页一级菜单     50        270(db,thymeleaf)                      
    三级分类数据获取 50         2(db)
    首页全量数据获取 50         7(静态资源)
    Nginx+Getway   50
    Getway+简单服务 50         3126
    全链路          50         800

# nginx动静分离
主要目的是将静态资源放在nginx，增快访问速度
  1）在nginx创建对应存放静态   
  2）配置nginx的config
    location /static/ {
        root /user/share.nginx/html
    }  
# 本地缓存和分布式缓存
那些数据适合放入缓存
    即时性、数据一致性要求不高的
    访问量大但是更新频率不高的
    电商类应用，商品分类，商品列表等适合缓存并加一个失效时间（根据数据更新频率来定）后台发布一个商品，买家需要5分钟才能看到新商品一般是可以接受的

分布式情况下就不应该使用本地缓存，应该使用统一的缓存redis
如果缓存中有就取出缓存中的内容，如果没有就去数据库取

redis堆外内存溢出解决OutOfDriectMemoryError
    sprignboot2.0以后默认使用lettuce作为redis客户端。使用netty进行网络通信
    lettuce的bug导致netty堆外内存溢出；netty如果没有指定堆外内存，默认使用-Xmx300m
    我们不能通过-Dio.netty.maxDIrectMemory进行设置
    解决方案：
        1）更改lettuce源码
        2）切换使用jdis

# 分布式系统下缓存问题
1）缓存穿透
    去查询一个指定不存在的数据，由于缓存不明中，将去查询数据库，但是数据库也没有记录，我们没有将这次查询为null的写入缓存，就会导致这个不存在的数据每次请求都到存储层失去缓存意义
    解决：
        null结果缓存，加入短暂过期时间
2）缓存雪崩
    redis缓存设置key的过期时间相同，导致缓存某一时刻同时失效，DB压力过大
    解决：
        在原有失效的基础上增加一个随机值，比如1-5分钟随机，避免大面积失效
3）缓存击穿
      对于一个设置了过期时间的key可能在某个时间点高并发的访问，是一种热点数据
      如果这个key在大量请求同时进行访问时正好失效，那么这些查询就会落到db
      解决：
        加锁：大量并发只让一个人去查，其他人等待，查到以后释放锁，其他人获得锁，先查缓存，就会有数据，不用去db  

# redis加锁来解决缓存击穿的问题
1，只要是同一把锁就能锁住需要这个锁的所有线程
synchronized(this)：springboot的组件在容器中都是单例的
//先查询缓存然后没有的话调用方法查询数据库
//数据库查询方法（整个方法加锁）
synchronized(this){
    //得到锁以后，还是应该先去缓存中确定一次，如果没有才需要继续查询
    //查询数据库
    //把查询出来的结果放到缓存
    //注意这几个步骤必须放在锁里面
}

# 分布式锁使用
集群的情况下这样加锁，最终有几个实例就有几个锁，所以我们需要使用分布式锁
基本原理就是利用setnx命令
//1，占分布式锁，去redis占坑
String uuuid = UUID.randomUUID().toString();
Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock", uuid, 300, TimeUnit.SECONDS);
if (lock) {
    //加锁成功
    //getDataFromDB然后返回
    //删除锁（非原子操作）
    //String lockValue = redisTemplate.opsForValue().get("lock");
    //if (uuid.equals(lockValue)) {
        //redisTemplate.delete("key");
    //}
    //删除锁，判断删除原子操作
    String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1])"
    redisTemplate.excute(new DefaultRedisScript<Integer>(script, Inteher.class, Arrays.asList('lock'), uuid));
} else {
    //加锁失败。。。重试
    //休眠10s
    //递归自旋重试
}
问题：
    1,setnx占好了位，业务代码异常或者程序在页面过程中宕机。没有执行删除锁逻辑，就造成死锁
    解决：设置自动过期，即便没有删除，也会自动删除
    2,给锁加过期时间和加锁必须是一个原子操作，否则加锁不一定会成功
    3,删除了其他线程加的锁（比如加锁时间是10s，业务也执行了10s，正好业务执行完该删除锁的时候，由于过期时间已到锁已经被删，这时候正好有其他线程获取到了锁，那么我们删除的就是其他线程的锁）
    解决：占锁的时候放一个uuid，然后删除的时候判断是不是自己的uuid，是的话再删除
    4,如果判断是否是自己的锁和删除锁不是一个原子也会有问题（在得到uuid返回时，正好锁过期了，返回的uuid是自己设置的，但是真正的锁设置的uuid是其他线程的，这样还是删除的是别人的锁）
    解决：将判断是否是自己的锁和删除锁做成一个原子操作
    4,业务超时，超过了锁的过期时间
    解决：设置超时时间长一点
# redisson分布式锁
注意：
    1，如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。这里注意，仅仅只是选择一台机器！这点很关键！
加锁：
    加锁的时候需要使用lua脚本，为什么使用lua脚本呢？保证这段复杂业务逻辑执行的原子性
    1，KEYS[1]代表的是你加锁的那个key，比如说：RLock lock = redisson.getLock("myLock"); 这里你自己设置了加锁的那个锁key就是“myLock”。
    2，ARGV[1]代表的就是锁key的默认生存时间，默认30秒。ARGV[2]代表的是加锁的客户端的ID，类似于下面这样：8743c9c0-0795-4907-87fd-6c719a6b4586:1
    3，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：
        hset myLock 
            8743c9c0-0795-4907-87fd-6c719a6b4586:1 1
        上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。
    4，锁互斥机制
        如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？
        很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。
        接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。
        所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。
        此时客户端2会进入一个while循环，不停的尝试加锁。
    5，watch dog自动延期机制
        客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？
        简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。
    6，可重入加锁机制
        那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？
        RLock lock = redisson.getLock("myLock");
        lock.lock()
        //业务代码开始
            lock.lock()
            //业务代码开始
            //业务代码结束
            lock.unlock()
        //业务代码结束
        lock.unlock()
        分析：
            第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。
            第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”
            此时就会执行可重入加锁的逻辑，他会用：incrby myLock 
                8743c9c0-0795-4907-87fd-6c71a6b4586:1 1
            通过这个命令，对客户端1的加锁次数，累加1。
            那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数
    7，释放锁机制
        如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。
        其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。
        如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：
        “del myLock”命令，从redis里删除这个key。
        然后呢，另外的客户端2就可以尝试完成加锁了。
示例：
    RLock lock = redisson.getLock("myLock");
    lock.lock()
    //1，锁会自动续期，如果业务超长，运行期间自动加上30s，不用担心业务过长锁自动过期
    //2，加锁业务只要运行完成，就不会给当前锁续期
    try {
        //业务代码执行
        Thread.sleep();
    } catch (Exception e) {
        //异常处理
    } finally {
        lock.unlock()
    }
看门狗原理
    lock.lock(10, TimeUnit.SECONDS)//设置了自动过期时间，这样是不会自动续期的
    //这里如果我们传递了超时时间，就发送给redis执行脚本，进行占锁，默认超时时间就是我们指定的时间
    //如果我们未指定超时时间，就使用LockWatchTimeout看门狗的过期时间，只要占锁成功，就会启动一个定时任务（重新给锁设置过期时间，每隔十秒续期，过期时间就是看门狗的默认时间）
读写锁：
    //应用：保证一定能读取到最新数据
    //写锁是一个排它锁（互斥锁），读锁是一个共享锁
    //写锁没释放，读锁就必须等待
    public String writeValue() {
        //改数据加写锁，读数据加读锁
        RReadWriteLock lock = redisson.getReadWriteLock("rw-lock");
        RLock wLock = lock.writeLock();
        wLock.lock();
        String s = UUID.randomUUID().toString();
        Thread.sleep(30000);
        redisTemplate.opsForValue().set("writeValue", s)
        wLock.unlock();
        return s;
    }
    public String readValue() {
        RReadWriteLock lock = redisson.getReadWriteLock("rw-lock");
        RLock rLock = lock.readLock();
        rLock.lock();
        String s = redisTemplate.opsForValue().get("writeValue");
        rLock.unlock();
        return s;
    }
    
    
    
    


# 
微服务注册中心的注册表如何更好的防止读写并发冲突？
2、Nacos如何支撑阿里巴巴内部上百万服务实例的访问？
3、Nacos高并发异步注册架构知道如何设计的吗？
4、Eureka注册表多级缓存架构有了解过吗？
5、Sentinel底层滑动时间窗限流算法怎么实现的？
6、Sentinel底层是如何计算线上系统实时QPS的？
7、Seata分布式事务协调管理器是如何实现的？
8、Seata分布式事务一致性锁机制如何设计的？
9、Seata分布式事务回滚机制如何实现的？
10、Nacos集群CP架构底层类Raft协议怎么实现的？
11、Nacos&Eureka&Zookeeper集群架构都有脑裂问题吗？
12、如何设计能支撑全世界公司使用的微服务云架构？
13、RocketMQ架构如何设计能支撑每天万亿级消息处理？
14、RocketMQ在交易支付场景如何做到消息零丢失？

                   
    