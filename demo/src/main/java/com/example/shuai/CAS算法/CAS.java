package src.main.java.com.example.shuai.CAS算法;

public class CAS {
    //CAS的定义（CompareAndSwap）
    //一个线程失败或挂起并不会导致其他线程也失败或挂起，那么这种算法就被称为非阻塞算法。
    //而CAS就是一种非阻塞算法实现，也是一种乐观锁技术，它能在不使用锁的情况下实现多线程安全，所以CAS也是一种无锁算法。


    //CAS（CompareAndSwap）比较并交换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。
    //CAS具体包括三个参数：当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，
    // 将内存值修改为B并返回true，否则什么都不做，并返回false。CAS 有效地说明了“ 我认为位置 V 应该包含值 A，如果真的包含A值，则将 B 放到这个位置，否则，不要更改该位置，只告诉我这个位置现在的值(A)即可。
    // ”整个比较并交换的操作是原子操作。

    //使用CAS就可以不用加锁来实现线程安全。
    //原子更新的基本类型包括：
    //AtomicBoolean：原子更新布尔变量；
    //AtomicInteger：原子更新整型变量；
    //AtomicLong：原子更新长整型变量；


    //CAS的缺点：
    //【1】循环时间长、开销很大。
    //当某一方法比如：getAndAddInt执行时，如果CAS失败，会一直进行尝试。如果CAS长时间尝试但是一直不成功，可能会给CPU带来很大的开销。
    //【2】只能保证一个共享变量的原子操作。
    //当操作1个共享变量时，我们可以使用循环CAS的方式来保证原子操作，但是操作多个共享变量时，循环CAS就无法保证操作的原子性，这个时候就需要用锁来保证原子性。
    //3】存在ABA问题
    //ABA问题是CAS中的一个漏洞。CAS的定义，当且仅当内存值V等于就得预期值A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。那么如果先将预期值A给成B，再改回A，那CAS操作就会误认为A的值从来没有被改变过，这时其他线程的CAS操作仍然能够成功，但是很明显是个漏洞，因为预期值A的值变化过了。如何解决这个异常现象？
    //java并发包为了解决这个漏洞，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性，即在变量前面添加版本号，每次变量更新的时候都把版本号+1，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
}
