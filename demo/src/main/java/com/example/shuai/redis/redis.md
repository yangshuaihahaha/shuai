# 五种数据类型
## ①String 是 Redis 最基本的类型
常用命令：set,get,decr,incr,mget 
常规key-value缓存应用，常规的计数

## ②Hash是一个键值（key-value）的集合
常用命令： hget,hset,hgetall 
hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 
比如我们可以 hash 数据结构来存储用户信息，商品信息等等。

## ③List 列表是简单的字符串列表，按照插入顺序排序
常用命令: lpush,rpush,lpop,rpop,lrange
list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。
Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。


## ④Set 是 String 类型的无序集合。
常用命令： sadd,spop,smembers,sunion
当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择。
并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

## ⑤Sorted Set
常用命令： zadd,zrange,zrem,zcard
和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。


# Redis过期时间
在Redis的expires字典中保存了数据库中所有键的过期时间，所以叫过期字典。
- 过期字典的key是一个指针，指向键空间的某个键对象（就是数据库键）
- 过期字典的value是一个long类型的整数，这个整数保存了键所指向的数据库键的过期时间，一个毫秒精度的UNIX时间戳
## 过期键判定
- 判断key是否存在于过期字典中
- 通过过期字典拿到key的过期时间，判断当前UNIX时间戳是否大于key时间
## 重点：过期键的删除策略
### 定时删除：
设置过期键的同时，设定设定定时器，通过定时器来主动删除过期键。
这种方式对内存友好，但是对cpu最不友好；定时器的设定需要使用redis服务器的时间事件（无序链表），查找的事件复杂度为O(n);故在过期键过多时，cpu的大部分占用是用来查找过期键和删除过期键的。
### 惰性删除：
每次对key进行操作时，判断当前key是否过期，再进行操作。
这种方式很明显对内存是不友好的，key过期的话仍然会一直存在数据库中，直到下次有对这个key的操作。
### 定期删除：
定期删除指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。
因为key太多，如果全盘扫描所有的key会非常耗性能，所以是随机抽取一些key来删除。这样就有可能删除不完，需要惰性删除配合。

但有些过期的key既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，占用内存，长期下去可能会导致内存耗尽。所以Redis提供了内存淘汰机制来解决这个问题。

# 内存淘汰机制
**MySQL里有2000w数据，Redis中只存20w的数据，内存淘汰机制可以保证Redis中的数据都是热点数据**
Redis在使用内存达到某个阈值（通过maxmemory配置)的时候，就会触发内存淘汰机制，选取一些key来删除。内存淘汰有许多策略，下面分别介绍这几种
- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
如何进行选择呢？
如何选取合适的策略？比较推荐的是两种lru策略。根据自己的业务需求。
如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru；
如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru。

# redis事务
redis的事务更像是一组命令的集合。
开启事务后我们可以同时执行一组命令，这些命令在事务执行前，不会进行入队的操作
## 1，如果事务执行时，命令集合存在书写错误，那么整个集合的命令都不会执行
- 如参数数量错误、参数名错误等等，或者其他更严重的错误，比如内存不足
- 对于这种情况，Redis早些时候会在事务执行前检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败
- 如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务
## 2，如果命令编译通过，存在运行时异常，那么其他命令仍会执行，存在异常的命令执行失败
- 比如使用 incy命令对一个非整形数据进行原子 +1操作
## 3，事务是可以取消的，事务取消，入队的命令不会执行
- 可以手动使用命令取消，也可以直接 ctrl + F4强制取消（在事务未被执行前打断施法即可
不存在原子性之外，Redis中的事务也没有隔离级别的概念


# Redis 雪崩了解吗？
热点数据的缓存都是定时任务去刷新，如果首页所有 Key 的失效时间都是某一个时间节点，这个时间大量用户涌入，这些请求全部落在了数据库上这就是缓存雪崩
每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。


# Redis 穿透
缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据
而用户不断发起请求。攻击导致数据库压力很大，严重会击垮数据库。

缓存穿透我会在接口层增加校验

# Redis 击穿
某一个 Key 不停地扛着大量的请求，Key 在失效的瞬间，持续的大并发直接落到了数据库上
设置热点数据永不过期

Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）

# Redis如何进行持久化
##1，RDB
### 什么是RDB
在指定时间间隔内，将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存中，来达到恢复数据的。
### 会不会影响性能
Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写进一个临时文件中，等到持久化过程结束了，再用这个临时文件替换上次持久化好的文件。在这个过程中，只有子进程来负责IO操作，主进程仍然处理客户端的请求，这就确保了极高的性能。
### 如何触发持久化
如何触发持久化呢？可以通过查看或者设置redis.conf配置文件来指定触发规则。
### 优点
1，如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。
2，RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。
3，RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。
### 缺点
1，RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。
2，每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。

## 2，AOF
### 什么是AOF
以日志的形式记录Redis每一个写操作,将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件不可以改写文件.
redis启动之后会读取appendonly.aof文件来实现重新恢复数据，完成恢复数据的工作。
默认不开启，需要将redis.conf中的appendonly  no改为yes启动Redis。
### 持久化策略
appendfsync always:每修改同步，每一次发生数据变更都会持久化到磁盘上，性能较差，但数据完整性较好。
appendfsync everysec: 每秒同步，每秒内记录操作，异步操作，如果一秒内宕机，有数据丢失。
appendfsync no:不同步。
### 数据恢复
重启Redis时，如果dump.rdb与appendfsync.aof同时都存在时，Redis会自动读取appendfsync.aof文件，通过该文件中对数据库的日志操作，来实现数据的恢复
### 重写
当然如果AOF 文件一直被追加，这就可能导致AOF文件过于庞大。因此，为了避免这种状况，Redis新增了重写机制，当AOF文件的大小超过所指定的阈值时，Redis会自动启用AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewiteaof。
### 优点
1，AOF有着多种持久化策略
2，AOF文件是一个只进行追加操作的日志文件，对文件写入不需要进行seek，即使在追加的过程中，写入了不完整的命令（例如：磁盘已满），可以使用redis-check-aof工具可以修复这种问题
3，Redis可以在AOF文件变得过大时，会自动地在后台对AOF进行重写：重写后的新的AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建AOF文件的过程中，会继续将命令追加到现有的AOF文件中，即使在重写的过程中发生宕机，现有的AOF文件也不会丢失。一旦新AOF文件创建完毕，Redis就会从旧的AOF文件切换到新的AOF文件，并对新的AOF文件进行追加操作。
4，AOF文件有序地保存了对数据库执行的所有写入操作。这些写入操作一Redis协议的格式保存，易于对文件进行分析；例如，如果不小心执行了FLUSHALL命令，但只要AOF文件未被重写，通过停止服务器，移除AOF文件末尾的FLUSHALL命令，重启服务器就能达到FLUSHALL执行之前的状态。
### 缺点
1，对于相同的数据集来说，AOF文件要比RDB文件大。
2，根据所使用的持久化策略来说，AOF的速度要慢与RDB。一般情况下，每秒同步策略效果较好。不使用同步策略的情况下，AOF与RDB速度一样快。

## 3，AOF
1，一般来说，如果想达到足以媲美PostgreSQL的数据安全性，应该同时使用两种持久化方式。
2，有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。
3，如果可以承受输分钟内的数据丢失，可以只使用RDB持久化。

# Redis为什么是单线程还那么快
1，Redis是基于内存实现的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2，数据结构简单，对数据的操作也简单
3，采用单线程，避免了不必要的上下文切换，不用考虑锁的问题。
4，Redis的多路复用机制

# Redis的多路复用机制
多路指的是网络连接，复用指的是同一个线程。
一个线程监听多个IO事件，当有IO事件就绪时，就会通知相应的线程去执行相应的读写操作
没有就绪事件时就会交出cpu。

## select 机制
### 基本原理：
客户端操作服务器时就会产生这三种文件描述符(简称 fd)：writefds(写)、readfds(读)、和 exceptfds(异常)。select 会阻塞住监视 3 类文件描述符，等有数据、可读、可写、出异常 或超时、就会返回；
返回后通过遍历 fdset 整个数组来找到就绪的描述符 fd，然后进行对应的 IO 操作。
### 优点：
几乎在所有的平台上支持，跨平台支持性好。
### 缺点：
1.由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
2.每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用 户空间)
3.默认单个进程打开的 FD 有限制是 1024 个，可修改宏定义，但是效率仍然慢。
## poll 机制：
## 基本原理：
基本原理与 select 一致，也是轮询+遍历；唯一的区别就是 poll 没有最大文件描述符限制（使用链表的方式存储 fd）。

## epoll 机制：
### 基本原理
没有 fd 个数限制，用户态拷贝到内核态只需要一次，使用时间通知机制来触发。通过 epoll_ctl 注册 fd，一旦 fd 就绪就会通过 callback 回调机制来激活对应 fd，进行相关的 io 操作。
### 优点：
1.没 fd 这个限制，所支持的 FD 上限是操作系统的最大文件句柄数，1G 内存大概支持 10 万个句柄
2.效率提高，使用回调通知而不是轮询的方式，不会随着 FD 数目的增加效率下降
3.内核和用户空间 mmap 同一块内存实现(mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间).

# redis双写一致性







