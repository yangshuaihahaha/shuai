# 栈指令集架构和寄存器指令集架构
1，可移植性比较
基于栈式结构不需要硬件支持，可以实现跨平台
基于寄存器架构则完全依赖硬件，可移植性差
2，设计比较
基于栈式架构使用零地址方式分配（没有地址，只有操作数），避开了寄存器分配难题，适用于资源受限系统
寄存器架构往往使用一地址指令，二地址指令，三地址指令为主
3，速度比较
基于栈式指令是在内存中操作，而寄存器直接在cpu执行，速度更快
4，指令集数量比较
完成相同的操作，基于栈式结构比基于寄存器架构指令集数量多，但是指令集小


# jvm生命周期
1，实例的诞生
任何class文件的main函数都可以认为是jvm示例的起点。
当一个程序启动，伴随的就是jvm实例的诞生，程序关闭jvm实例就消亡。
任何一个拥有公开的（public）、静态的（static）、没有返回值（void）并且接受一个字符串数组参数（String[] args） 的main()函数的class都可以作为JVM实例运行的起点 。
2，实例的运行
main作为该程序初始线程的起点，任何其他线程都由该线程启动，
JVM内部有两种线程：守护线程和用户线程，main()属于用户线程，守护线程通常由JVM自己使用，如GC线程。
java程序也可以标明自己创建的线程是守护线程。
java程序的初始线程 只就是运行main（）的线程，这个线程是用户线程，只要还有任何非守护线程还在运行，那么jvm就存活着。
3，实例的消亡
所有用户线程都终止时，JVM才退出；
若安全管理器允许，程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出。



# java类加载
## 1，什么是类加载器
- ClassLoader就是动态加载class文件到内存中的（class文件就是二进制的字节流）
- 只有加载到内存中的class文件才能被其他的文件引用
## 2，类加载过程
java程序是由多个class文件组成的，一个类中可能引用多个其他的类，当缺少一些class文件的时候就会出现异常
程序加载class文件的时候不会一次性加载所有的文件，而是通过java的类加载机制动态的加载class文件到内存中

### 第一步，加载（查找和导入类或接口的二进制数据）
通过一个类的全限定名来获取其定义的二进制字节流
将这个字节流所代表的静态存储结构转化为方法取的运行时数据结构
在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

### 第二步，验证（检查导入类或接口的二进制数据的正确性）
目的在于确保class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会包含虚拟机的安全

主要是文件格式的验证、元数据的验证、字节码验证、符号引用验证
例如校验加载的.class文件内容是否符合指定的规范（例如字节码文件被篡改）
文件格式验证
该阶段主要在字节流转化为方法区中的运行时数据时，负责检查字节流是否符合Class文件的规范，保证其可以正确的被解析并存储于方法区中。后面的检查都是基于方法区的存储结构进行检验，不会再直接操作字节流。
元数据验证
该阶段负责分析存储于方法区的结构是否符合Java语言规范的要求，如该类是否继承了不允许继承的类（被final修饰的类）、是否包含父类等。此阶段进行数据类型的校验，保证符合不存在非法的元数据信息。
字节码验证
元数据验证保证了字节码中的数据类型符合语言的规范，该阶段则负责分析数据流和控制流，确定方法体的合法性，保证被校验的方法在运行时不会危害虚拟机的运行。
符号引用验证
最后一个阶段发生在链接的解析阶段。在解析阶段，会将虚拟机中的符号引用转化为直接引用，该阶段则负责对各种符号引用进行匹配性校验，保证外部依赖真实存在，并且符合外部依赖类、字段、方法的访问性。

### 第三步，准备（给类的静态变量分配并初始化存储空间）
准备阶段主要是将类变量（被static修饰符修饰）在方法区进行内存分配并进行初始化。

这里不包含用final修饰的static，因为final在编译的时候就会分配内存了，准备阶段会显式的初始化
这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量会随着对象一起分配到Java中

### 第四步，解析（将符号引用转成直接引用）
解析阶段将符号引用替换为直接引用

1）、类或接口解析：将符合引用转化为类的直接引用，并检查访问权限。
2）、字段解析：将字段的符号引用转化为字段所属的类信息或其父类该字段的直接引用，并检查访问权限。
3）、类方法解析：将类方法的符号引用转化为类方法所属的类信息或其父类该字段的直接引用，并检查访问权限。
4）、接口方法解析：将接口方法的符号引用转化为接口方法所属的接口信息或其父类该字段的直接引用，并检查访问权限。

### 第五步，初始化（激活类的静态变量的初始化Java代码和静态Java代码块（<clinit>()））

- 初始化就是执行类构造器方法<clinit>()的过程，为类的静态变量赋予正确的初始值
这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中语句合并而来
- <clinit>()不同于类构造器。（构造器是虚拟机视角下的<init>()）
如果该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕
- 虚拟机必须保证一个类的<clinit>()方法在多线程下同步加锁


# 主动引用和被动引用
首先我们需要知道java对类的使用方式分为2种：主动使用和被动使用。
每个类或接口只有被java程序主动使用时才会被初始化。
  
# 类初始化时机 （主动使用会被初始化）
类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
– 创建类的实例，也就是new的方式
– 访问某个类或接口的静态变量，或者对该静态变量赋值
– 调用类的静态方法
– 反射（如Class.forName(“com.shengsiyuan.Test”)）
– 初始化某个类的子类，则其父类也会被初始化
– Java虚拟机启动时被标明为启动类的类（Java Test）

# 类的卸载时机
类的卸载跟垃圾回首算法有关，在CMS中有两种方法卸载不必要的类
1，一种是等到元空间满了的时候出发FGC
2，另一种是使用跟CMS并发收集算法类似的方式
jvm中一个类的卸载必须满足：
1，该类的所有实例对象都被回收
2，该类的加载器对象被回收
3，该类对应的java.lang.CLass对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法


# 类加载器
1，根类加载器（引导类加载器（BootstrapClassLoader））
负责加载JAVA中的一些核心类库，负责加载JAVA_HOME中jre/lib/rt.jar里所有的class
2，扩展类加载器（extensions class loader）
主要加载JAVA中的一些拓展类，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
3，系统类加载器
主要用于加载CLASSPATH路径下我们自己写的类
```
public class CLassLoaderTest {
    public static void main(String[] args) {
        //获取系统加载器
        ClassLoader systemCLassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemCLassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

        //获取其上层，扩展类加载器
        ClassLoader exCLassLoader = systemCLassLoader.getParent();
        System.out.println(exCLassLoader);//sun.misc.Launcher$ExtClassLoader@1be6f5c3

        //获取其上层
        ClassLoader bootstrapCLassLoader = exCLassLoader.getParent();
        System.out.println(bootstrapCLassLoader);//null

        //对于用户自定义类来说，默认使用系统类加载器进行加载
        ClassLoader classLoader = CLassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

        //String类使用引导类加载器进行加载 --> java的核心类使用引导类加载器进行加载
        ClassLoader strClassLoader = String.class.getClassLoader();
        System.out.println(strClassLoader);//null

    }
}
```

# 双亲委派机制
## 概述
1，如果一个类加载器收到了类加载请求，并不会自己去加载，而是把这个请求委托给父类加载器执行
2，如果父类加载器还存在父类加载器，则会进一步向上委托，依次递归最终到达顶层的启动类加载器
3，如果父类加载器可以完成类加载，就成功返回。如果父类加载器无法完成加载任务，子加载器才会尝试自己加载

## 优势
避免类的重复加载
保护程序安全，防止核心API被篡改

# jvm中怎么判断两个class对象是否为同一个类
1，类的完成名必须一致，包括包名
2，加载这个类的CLassLoader必须相同

# Jvm运行时数据区
Java虚拟机定义若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。
另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

线程私有：程序计数器，虚拟机栈，本地方法栈
线程共享：堆，方法区（永久代或元空间，代码缓存）

# 程序计数器：（PC寄存器）
作用：
PC寄存器用来存储指向下一条指令的地址，也就是将要执行的指令代码。由执行引擎读取下一条指令
特点：
- 程序计数器占用内存很少
- 每个线程都有自己的独立计数器
- 任何一个线程都有一个方法在执行，也就是当前方法。程序计数器会存储当前线程正在执行的java方法jvm指令地址。
- jvm规范中唯一一个没有规定OutOfMemoryError（OOM）异常，就是不会发生内存区超限，无GC
- 它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都依赖这个计数器完成
为什么需要PC寄存器：
CPU之间需要不停的切换各个线程，这时候切换回来后，就不知道从哪里开始执行
为什么PC寄存器是私有的：
因为为了记录各个线程正在执行的当前字节码指令，最好的办法自然是为每一个线程分配一个PC寄存器

# 堆空间和栈空间
- 一般来讲，对象主要放在堆空间，是运行时数据比较大的一块
- 栈空间存放：它保存方法的局部变量（8种基本数据类型，对象的引用地址），基本数据类型的局部变量，以及引用数据类型对象的引用







# 虚拟机栈（本地方法栈）
## 1，基本概述
- 每个线程创建的时候都会又一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的java调用
- 线程私有
- 生命周期和线程一致
- 主管Java程序的运行，它保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回
- 无GC，存在OMM
- jvm直接对java栈的操作只有两个
1，每个方法执行，伴随着进栈（入栈，压栈）
2，执行结束后出栈
- 对栈来说不存在垃圾回收：没有GC，只有OMM

## 2，存储结构和运行原理
### 2.1，栈存储内容
- 每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在
- 在线程上正在执行的方法都对应各自的一个栈帧（方法的执行和结束对应着栈帧的入栈和出栈）
- 栈帧是一个内存区块，一个数据集，维系着方法执行过程中各种数据信息
### 2.2，栈运行原理
- jvm直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出和后进先出的原则
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧是有效的，
这个栈帧被称为当前栈帧，与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果该方法中调用了其他的方法，对应新的栈帧会被创建出来，放在栈的顶端，成为新的栈帧
- 不同线程中所包含的栈帧是不允许相互引用的（数据不共享），即不可能在另一个栈帧中引用另外一个线程的栈帧。
不同线程可以共享他们在同一进程中的堆空间和方法区
- 如果当前方法调用了其他的方法，方法返回之际，当前栈帧会传回此方法的执行结果前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- java方法有两种返回函数的方式
1，一种是正常函数返回
2，一种是抛出异常

## 3，栈帧内部结构
- 局部变量表（Local Variables）
- 操作数栈（operand static）（或表达式栈）
- 动态链接（dynamic linking）（或指向运行时常量的方法引用）
- 方法返回地址（return address）（或指向运行时常量池的方法引用）
- 方法返回地址（return address）（或方法正常推出或异常退出的定义）
### 3.1，局部变量表
- 定义一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括基本数据类型，对象引用，以及returnAddress
- 由于局部变量都建立在线程的栈上，因此不存在数据安全问题
- 局部变量表所需容量大小是在编译时期确定下来的，运行期间不会更改变量表的大小
- 方法嵌套调用的次数由栈的大小决定。栈越大，方法嵌套调用的次数越多。对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，
以满足方法调用所传递的信息量增大的需求，进而函数占用更多的栈空间，导致嵌套调用的次数减少
-局部变量表中的变量只在当前方法中有效。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

#### 3.1.1，局部变量槽（slot）
- 参数值总是放在局部变量的index0开始，到数组长度-1的索引结束
- 局部变量，最基本的单位是slot（变量槽）
- 局部变量表中存放着编译期可知的各种基本数据类型（8种），引用数据类型（reference），returnAddress类型的变量
- 局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64的类型（double和long）占用两个slot
  -> byte，short，char在存储前被转为int，boolean也被转为int，0表示false，非0表示true
  -> long和double占据两个slot
- jvm会为局部变量表中的每一个slot分配一个访问索引，通过这个索引可以成功访问到变量表中的局部变量值
- 当一个实例方法被调用，它的方法参数和方法体内部定义的局部变量会按照顺序复制到局部变量表的每一个slot上
- 如果需要访问局部变量中的一个64bit的局部变量值，只需要访问前一个索引就好
- 如果当前帧是由构造方法或者实例方法创建的，那么该对象this将会放在index为0的slot处，其余的参数按照参数表的顺序继续排列
- 栈帧中的局部变量表的slot是可以重复利用的

#### 3.1.2，操作数栈
- 操作数栈，主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间
- 操作数栈是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧被创建出来，这个方法的操作数栈是空的
- 每个操作数栈又一个明确的栈深度用于存储数值，在编译时期就定义好了。保存在方法的code属性中，为max_stack的值
- 栈中的任何一个元素都是任意的java数据类型
  -> 32bit的类型占用一个栈单位深度
  -> 64bit的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，只能通过标准的入栈和出栈完成数据访问
- 如果被调用方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令
- 操作数栈中的元素数据类型必须与字节码指令的序列号严格匹配，这由编译器期间进行验证，同时在类加载过程中类校验阶段的数据流分析阶段再次验证
- 另外，我们说java虚拟机的解释引擎是基于栈的执行引擎，其中栈指的是操作数栈

#### 3.1.3，动态链接（指向运行时常量池的方法引用）
- 每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个他引用的目的是为了支持当前方法的代码能够实现动态链接
- 在Java源文件被编译到字节码文件中时，所有的变量和方法都作为符号引用保存在常量池中。比如：描述一个方法调用了另外的其他方法，就是通过常量池中指向方法的符号引用来表示的
那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

#### 3.1.4，方法返回地址
存放的是该方法的pc寄存器的值
一个方法的结束有两种方式：
1，正常执行完成
2，出现未处理的异常，非正常退出
无论哪种方式退出，在方法退出后都返回该方法调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即该方法的指令的下一条指令的地址。而通过异常退出，返回地址是要通过异常表来确定

# jvm方法的调用
在jvm中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关
## 1，静态链接
当一个字节码文件被装载进jvm内部时，如果调用的目标方法在编译期可知，且运行期间保持不变，这种情况下将调用方法的符号引用转为直接引用的过程称之为静态链接
## 2，动态链接
如果被调用的方法编译期无法确定下来，可就是说只能够在程序运行期间将调用的方法的符号引用转为直接引用，由于被转换的过程中具备动态性，因此成为动态链接
**比如接口方法的调用**
## 3，虚方法和非虚方法
- 如果方法在编译时期就确定具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法
- 静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法
- 其他方法称为虚方法

# 方法中定义的局部变量是否线程安全
需要分情况
```
线程安全
public static void method1() {
    StringBuilder s1 = new StringBuilder();
    s1.append("a");
    s1.append("b");
}
线程不安全
public static void method2(StringBuilder s1) {
    s1.append("a");
    s1.append("b");
}
线程不安全
public static void method2() {
    StringBuilder s1 = new StringBuilder();
    s1.append("a");
    s1.append("b");
    return s1;
}
```

# 静态变量和局部变量对比
- 我们知道变量表有两次初始化机会，第一次是在"准备阶段"，执行系统初始化，对变量设置零值，另一次则是在"初始化"阶段，赋予程序员在代码中定义的初始值
- 和类变量初始化不同的是，局部变量不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为初始化，否则无法使用

# java的本地方法
简单的讲就是一个java调用非java代码的接口。用native来修饰，abstract不能和native连用。
## 1，为什么要使用native method
1，与java环境交互
有时Java应用需要与Java外面的环境交互，这就是本地方法存在的主要原因
2，与操作系统交互
通过使用本地方法，可以实现jre与底层系统交互，甚至jvm的一些部分就是用c写的
3，Sun's Java
Sun的解释器就是用c实现的，这使得他能像一些普通的c一样与外部交互

# java的本地方法栈
- java虚拟机用于管理java方法的调用，而本地方法栈用于管理本地方法的调用
- 本地方法栈，也是线程私有的
- 允许被实现成固定或者是可扩展的内存大小（在内存益处方面是相同的
- 本地方法栈是由c语言实现的
- 它的具体做法是native method stack中登记native方法，在execution engine执行时加载本地方法







# 堆的核心概述
- 所有的对象实例以及数组都应该分配在堆上
- 数组和对象可能永远不会储存在堆上，因为栈帧中保存引用，这个引用指向对象或数组在堆中的位置
- 方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收时被移除
- 堆，是GC执行的回收重点

# 堆空间的大小设置
Java堆区用于存储Java对象实例，堆的大小在启动时已经设定好了
-Xms用于表示堆区的起始内存，等价于-XX:InitialHeapSize
-Xmx则用于表示堆区最大内存，等价于-XX:MaxHeapSize
-XX:NewRatio:设置新生代老年代比例
-XX:SurvivorRatio:设置新生代Eden区与Survivor区的比例
-XX:UseAdaptiveSizePolicy:关闭自适应的内存分配策略（暂时用不到）
-Xmn:设置新生代的空间大小

通常我们会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区内存后不需要重新分隔计算堆区内存大小，从而提高性能

# 对象的分配过程
1，new对象先放在伊甸园区，此区域大小有限制
2，当伊甸园的空间填满时，程序又需要创建对象，jvm的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁
再加载新的对象到伊甸园区
3，然后将伊甸园区中的剩余对象移动到幸存者0区
4，如果再次出发垃圾回收，此时幸存者下来的放到幸存者0区，如果没有被回收，就会放到幸存者1区
5，如果再次触发垃圾回收，此时会重新放弃幸存者0区，接着去幸存者1区
6，啥时候去养老区呢？可以设置次数，默认是15次
   -> -XX:MaxTenuringThreshold=<N>进行设置
7，在养老区，相对悠闲。当养老区内存不足时，会再次触发Major GC，进行养老区的内存清理
8，若养老区执行了Major GC发现依然无法进行对象保存，就会产生OOM异常

总结：
- 针对幸存者s0，s1区：复制之后有交换，谁是空谁就是to
- 关于垃圾回收：频繁在新生区收集，很少在老年区进行收集，几乎不在永久区/元空间收集

# 常用的调优工具
- JDK命令
- Eclipse：Memory Analyzer Tool
- Jconsole
- Java Flight Recorder
- GCViewer 
- GC Easy

# Minor GC，Major GC，Full GC
Java在进行GC的时候，并非对上面三个内存一起回收的，大部分时候指的是新生代
针对HotSpot VM的实现，它里面的GC按照回收区域分为两大类：一种是部分收集，一种是整堆收集
- 部分收集：不是完整收集整个Java堆的垃圾回收，其中分为：
  -> 新生代收集（Minor GC）:只是新生代垃圾回收
  -> 老年代收集：只是老年代的垃圾回收
     目前，只有CMS GC会有单独收集老年代的行为
     注意，很多时候Major GC会和Full  GC混淆使用，需要具体分辨是老年代回收还是整体回收
  -> 混淆收集（Mixed GC）:收集整个新生代和部分老年代的垃圾回收
     目前只有G1 GC会有这种行为
- 整堆收集：收集整个Java堆和方法区垃圾回收

# 年轻代GC（Minor GC）触发机制
-> 当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是Eden代满，Survivor满不会引发GC，（每次Minor GC会清理年轻代内存）
-> 因为Java对象大多数对象都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快
-> Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才能恢复

# 老年代GC（Major GC/Full GC）触发机制
- 指的是发生在老年代的GC，对象从老年代消失，我们说Major GC或Full GC发生了
- 出现了Major GC经常会伴随至少一次Minor GC（但非绝对的，在Parallel Scavenage）收集器的收集策略里就有直接进行Major GC的策略选择过程
  -> 也就是在老年大空间不足时，会尝试触发Minor GC，如果之后空间还不足，则会触发Major GC
- Major GC的速度一般会比Minor GC慢10倍以上，STW时间更长
- 如果Major GC后内存还不足就会报OOM
- Major GC的速度一般会比MInor GC慢10倍以上

# Full GC触发机制
1，调用System.gc()时，系统建议执行Full GC，但是不必然执行
2，老年代空间不足
3，方法区空间不足
4，通过Minor GC后进入老年代的平均大小大于老年代可用内存
5，由Eden区，s0区向s1区复制时，对象大小已经小于to区的可用内存，则把该对象转到老年代，且老年代的可用内存小于该对象大小
说明：full gc是开发或者调优过程中尽量避免的，这样暂时时间会短一些

# 为什么进行Java分代
- 经研究，不同的对象生命周期不同，70%-90%的对象是临时对象
  -> 新生代：有Eden，两块大小相同的Survivor构成，to总是为空
  -> 老年代：存放新生代中经历多次GC仍然存活的对象
分代唯一的理由是优化GC性能。如果没有分代那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到那些对象没用，
这些就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到一个地方，当GC的时候先把这块存储"朝生夕死"对象进行回收，这样就会腾出很大的空间

# 内存分配策略（或者对象提升规则）
- 优先分配到Eden
- 大对象直接分配到老年代
  -> 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  -> 如果Survivor区中相同年龄的多有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代
     无需等到MaxTenuringThreshold要求的年龄值
- 空间分配担保
  -> -XX:HandlePromotionFailure 
  
# 空间内存分配担保
在发生Minor GC之前，虚拟机会检查老年代最大可用连接空间是否大于新生代所有的对象总空间
  -> 如果大于，则此次Minor GC是安全的
  -> 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
     -> 如果-XX:HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小
        -》如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的
        -》如果小于进行一次Full GC
     -> 如果-XX:HandlePromotionFailure=false，则改为进行一次Full GC
  
# 什么是TLAB
1，为什么会有TLAB(Thread Local Allocation Buffer)
- 堆是线程共享区域，任何线程都可以直接访问堆中的共享区域
- 由于对象实例的创建在jvm中非常频繁，因此在开发环境中从堆区划分内存空间是线程不安全的
- 为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

2，什么是TLAB
- 从内存模型而不是垃圾回收的角度，对Eden区域继续进行划分，jvm为每个线程分配了一个私有缓存区域
- 多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能够提升内存分配的吞吐量

# 堆空间的参数
-XX:+PrintFlagsInitial：查看所有的参数默认初始值
-XX:+PringFlagsFinal：查看所有参数的最终值
-XX:PringGCDetails：输出详细的GC处理日志
-Xms：初始堆空间内存（默认物理内存的1/64）
-Xmx：最大堆空间内存（默认物理内存的1/4）
-XX:NewRatio：配置新生代和老年代在堆结构中的占比
-XX:SurviorRatio：配置新生代中Eden/S0/S1的空间比例
-XX:MaxTenuringThreshold：设置新生代垃圾回收的最大年龄
-XX:HandlePromotionFailure：是否设置空间分配担保

# 逃逸分析
当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
当一个对象在方法中被定义后，被外部方法引用，则认为发生逃逸。例如作为调用参数传递到其他地方中

```
发生逃逸主要场景是:
private Person p;
1,变量赋值
public void methodC(){
    p = new Person();
}
2,实例引用传递
public void methodA(){
    Person Person = methodB();
    methodC();
}
3,方法返回值
public Person methodB(){
    Person person = new Person();
    return person;
}
```

# 逃逸分析，代码优化
## 1，栈上分配(没有发生逃逸才会进行栈上分配)。
指在Java程序的执行过程中，在方法体中声明的变量以及创建的对象，将直接从该线程所使用的栈中分配空间。 一般而言，创建对象都是从堆中来分配的，这里是指在栈上来分配空间给新创建的对象。
JVM允许将线程私有的对象打散分配在栈上（比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配），而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。
## 2，同步省略。
如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步
```
public class SynchronizedTest {
    public void f() {
        Object hollis = new Object();
        synchronized(hollis) {
            System.out.println(hollis);
        }
    }
}
同步省略之后
public class SynchronizedTest {
    public void f() {
        Object hollis = new Object();
        System.out.println(hollis);
    }
}
```
## 3，分离对象或标量替换。
标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。
```
public static void main (String[] args) {
	alloc(); 
}
private static void alloc() {
	Point point = new Point (1.2);
	System.out.println("point.x="+point.x+";point.y="+point.y);
}
class Point {
	private int X; 
	private int y;
}
经过标量替换后就会变成
private static void alloc() {
	int x=1; 
 	int y=2; 
 	System.out.println("point.x="+x+"; point.y="+y);
}
```
可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。


# 堆空间小结
- 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命
- 老年代放置长生命周期对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上
如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，jvm就会直接分配到老年代
- 当GC只发生在年轻代，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代则被称为Major GC或者Full GC。一般的，Minor GC的发生频率比Major GC
高很多，即老年代中垃圾回收发生的频率大大低于老年代


# 方法区的理解
方法区保存的是类的元数据。
方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存。
《Java虚拟机规范》中明确，"Java尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾回收或者进行压缩"，所以方法区可以看作是独立于Java堆空间的内存空间
- 方法区与Java堆一样，是各个线程共享的内存区域
- 方法区在jvm启动的时候被创建，并且它的实际物理内存空间中和Java堆区一样都可以是不连续的
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区益处，虚拟机就会抛出内存益处错误
  -> 加载大量的第三方jar包、Tomcat部署的工程过多、大量动态的生成反射类
- 关闭jvm就会释放这个区域的内存

# 方法区内部结构
1，类型信息
对每个加载的类型（类class、接口interface、枚举enum、注解annotation），jvm必须在方法区存储以下类型信息
一，这个类型的完整有效名称（全名=包名.类名）
二，这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
三，这个类型的修饰符（public，abstract，final的某个子集）
四，这个类型直接接口的一个有序列表

2，Field信息
- jvm必须在方法区保存类型的所有属性的相关信息以及属性的生命顺序
- 属性的相关信息包括：属性名称、属性类型、属性修饰符（public，protected，static，final，volatile，transient的某个子集）

3，方法信息
方法名称，方法返回类型，方法参数数量和类型，方法修饰符，方法字节码，操作数栈，局部变量表大小，异常表

4，类变量(即static变量）非final类变量
在java虚拟机使用一个类之前，它必须在方法区中为每个非final类变量分配空间。非final类变量存储在定义它的类中；
final类变量（不存储在这里）
由于final的不可改变性，因此，final类变量的值在编译期间，就被确定了，因此被保存在类的常量池里面，然后在加载类的时候，复制进方法区的运行时常量池里面 ；final类变量存储在运行时常量池里面，每一个使用它的类保存着一个对其的引用；

5，对类加载器的引用
jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。

6，对Class类的引用
jvm为每个加载的类都创建一个java.lang.Class的实例（存储在堆上）。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据（类的元数据）联系起来， 因此，类的元数据里面保存了一个Class对象的引用；

# 常量池和运行时常量池
常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型
## 1，常量池
主要是各种字面量和符号引用
- 字面量。
字面量就是比如说int a = 1; 这个1就是字面量。又比如String a = "abc",这个abc就是字面量。
是指字符串字面量和声明为final的（基本数据类型）常量值。这些字符串字面量除了类中所有双引号括起来的字符串（包括方法体内的）
还包括所有用到的类名、方法名和这些类与方法的字符串描述、字段名称和描述符；方法内的常量值由栈分配，所以并不算是字面量
- 符号引用。类和接口的全限定名、字段的名称和描述符、方法名称和描述符。
只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用。

## 3，运行时常量池
java文件被编译成class文件后就会生成常量池。jvm在执行某个类的时候，必须经过加载、连接、初始化,而连接又包括验证、准备、解析三个阶段。
- 当类加载到内存中后，jvm就会将class常量池中的内容放到运行时常量池中，
- 还会把翻译出来的直接引用也存储到运行时常量池中
- 行时常量池具备动态性，也就是并非预置入Class文件的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中
- 运行时常量池也是每个类都有一个。
class常量池存的是字面量和符号引用，也就是说他们存放的并不是对象的实例，而是对象的符号引用值。经过解析后，也就是把符号引用替换为直接引用（直接指向内存中的地址）。
解析过程中会去查询全局字符串池，以保证运行时常量池所引用的字符串和全局字符串池中的引用是一致的

```
举个实例来说明一下:
public class HelloWorld {
    public static void main(String []args) {
		String str1 = "abc"; 
		String str2 = new String("def"); 
		String str3 = "abc"; 
		String str4 = str2.intern(); 
		String str5 = "def"; 
		System.out.println(str1 == str3);//true 
		System.out.println(str2 == str4);//false 
		System.out.println(str4 == str5);//true
    }
}
```
首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。
上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。


# 为什么需要常量池
一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要更多数据支持，通常这种数据很大以至于不能直接存到字节码里。
换一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。


# 方法区的演进
jdk8完全放弃了永久代的概念，改用JRockit、J9一样在本地内存中实现元空间来代替
元空间的本质和永久带类似，都是对jvm规范中方法区的实现，不过元空间和永久带的最大区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存

jdk1.6及以前：有永久代，静态变量放在永久代上
jdk1.7：有永久代，但是已经在逐步"去永久代"，字符串常量池，静态变量移除，保存在堆中
jdk1.8及以后：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中

# 设置方法区内存大小（jdk1.8）
-XX:MetaspaceSize：设置初始元空间大小。
-XX:MaxMetaspaceSize：最大元空间大小
对于一个64位的服务器jvm来说，其默认值是21mb，这是高水位，一旦超过这个高水位，Full GC将会被触发并卸载没用的类，然后这个高水位会被重置。
新的高水位取决于GC后释放了多少元空间，如果释放的空间不足，那么在不超过-XX:MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则降低该值
如果初始化的内存设置过低，上述高水位调整情况会发生多次。为了避免频繁的Full GC建议将-XX:MetaspaceSize设置为一个较大的值

# 方法区垃圾收集
一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是部分区域的回收有时候确实是必要的。
方法区的垃圾回收主要是两部分：常量池中废弃的常量和不使用的类型

1，常量的回收
HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就被回收

2，类的回收
满足一下条件允许被回收
- 该类的所有实例被回收，也就是Java堆中不存在该类的任何派生子类
- 加载该类的类加载器被回收（这个条件除非是经过精心设计的可替换类加载器场景，如OSGI、JSP的重载等，否则很难达成）
- 该类对应的java.lang.CLass对象没有在任何地方被引用，无论任何地方无法通过反射访问该类方法
这里满足条件后仅仅是被"允许"，并不是和其他对象一样，没有了就必然被回收。

# 如何解决OOM
1，要解决OOM异常或heap space异常，一般的手段是首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的
也就是首先要分清楚到底是出现了内存泄漏还是内存溢出
2，如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾回收器无法自动回收的
掌握了泄漏对象的类型信息，以及GC Roots引用链信息，就可以比较准确的定位出泄漏代码位置
3，如果不存在内存泄漏，换句话说就是内存中的对象都还必须存活着，那就应当检查虚拟机参数，与机器物理内存对比看是否可以调大，从代码上检查是否存在
某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗

# StringTable为什么要调整
因为永久代的回收效率很低，只有在full GC的时候才会触发。而full GC是老年代空间不足、永久代不足时才会触发。
这就导致StringTable回收效率不高，而开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。


# 问题
1，Java8分代改进
2，jvm内存分区，每个最用是什么
3，jvm内存分布、堆和栈的区别、堆的结构、为什么有两个survivor区
4，为什么要有新生代和老年代
5，对象什么时候会进入老年代
6，jvm为什么要分成新生代，老年代，持久代，新生代为什么要分Eden和Survivor
7，jvm内存模型在java8中做了什么修改
8，jvm永久代会发生垃圾回收么





 










  


